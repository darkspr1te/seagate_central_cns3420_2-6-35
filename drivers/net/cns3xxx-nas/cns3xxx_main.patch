--- a/drivers/net/cns3xxx/cns3xxx_main.c	2011-10-06 22:46:17.005803784 +0800
+++ b/drivers/net/cns3xxx/cns3xxx_main.c	2011-10-06 22:47:20.865803795 +0800
@@ -22,8 +22,9 @@
  ********************************************************************************/
 
 #include <linux/module.h>
-
-#include "../cns3xxx_pse_init/cns3xxx.h"
+//#include <mach/board.h>
+#include "../../cns3xxx_pse_init/cns3xxx.h"
+//#include "cns3xxx.h"
 #include "cns3xxx_tool.h"
 #include "cns3xxx_config.h"
 #include <linux/cns3xxx/pse_init_common.h>
@@ -40,16 +41,17 @@
 #if defined (CONFIG_CNS3XXX_ETHADDR_IN_FLASH)
 #include <linux/mtd/mtd.h>
 #endif
+#define CONFIG_CNS3XXX_JUMBO_FRAME
+#define RX_DESC_SIZE 1024
+#define TX_DESC_SIZE 2048
+#define MAX_PACKET_LEN 9018 //KH: set to 9014 + 4 for Intel E1000E ( 9301CT)
+#define MIN_PACKET_LEN 14
 
-#ifdef CNS3XXX_SG_DEBUG
-static u32 sg_time = 0;
-#endif
-
+extern struct proc_dir_entry *cns3xxx_proc_dir;
 extern NetDevicePriv net_device_prive[10];
 
 #define RX_SDP_ALIGN 64
 
-static ushort MAX_PACKET_LEN = 1536;
 #define CPU_CACHE_BYTES         64
 #define CPU_CACHE_ALIGN(X)      (((X) + (CPU_CACHE_BYTES-1)) & ~(CPU_CACHE_BYTES-1))
 
@@ -58,99 +60,43 @@
 atomic_t cpufreq_pse_flag;
 #endif
 
-#if defined (CONFIG_CNS3XXX_ETHADDR_IN_FLASH)
-
-#define MTD_READ(mtd, args...) (*(mtd->read))(mtd, args)
-
-#ifdef CONFIG_CNS3XXX_MAC_IN_SPI_FLASH
-#define ENV_OFFSET 0x30000
-#define PARTITION_NAME "SPI-UBoot"	/* refer to cns3xxx_spi_flash_partitions */
-#else
-#define ENV_OFFSET 0x0
-#define PARTITION_NAME "UBootEnv"
-#endif
-
-#define MTD_READ_LEN 1024
-
-static char mtd_str[MTD_READ_LEN], ethaddr[12]={0};
-
-static int init_mtd_env(void)
-{
-	struct mtd_info *mtd;
-	size_t retlen=0;
-
-	mtd = get_mtd_device_nm(PARTITION_NAME);
-
-	if (IS_ERR(mtd)) { return -ENODEV; }
-	
-	MTD_READ(mtd, ENV_OFFSET, MTD_READ_LEN, &retlen, mtd_str);
-
-	return 0;
-}
-
-int fmg_get(const char *name, int *ret_len)
-{
-	int i,j,x,z;
-	int nlen = strlen(name);
-	char tmp_str[20];
-
-	memset(ethaddr,0x0,12);
-
-	for(i=0;i<MTD_READ_LEN-nlen;i++) {
-		z=0;
-		for(x=0;x<nlen;x++){if(mtd_str[i+x]==name[x]){z++;}}
-		/* printk("z = %d , nlen = %d\n",z,nlen); */
-		if(z==nlen) {
-			memcpy(tmp_str,mtd_str+i+nlen,17);
-			tmp_str[17] = '\0';
-			/* printk("tmp_str = [%s]\n",tmp_str); */
-			for(j=0;j<17;j++){if(tmp_str[j]!=':'){sprintf(ethaddr,"%s%c",ethaddr,tmp_str[j]);}}
-			*ret_len = strlen(ethaddr);
-			return 0;
-		}
-	}
-	return -1;
-}
-
-int mac_str_to_int(const char *mac_str, int mac_str_len, u8 *mac_int, int mac_len)
-{
-	int i=0,j=0;
-	char mac_s[3]={0,0,0};
-
-	for (i=0 ; i < mac_str_len ; i+=2) {
-		mac_s[0] = mac_str[i];
-		mac_s[1] = mac_str[i+1];
-		mac_int[j++] = simple_strtol(mac_s, NULL, 16);
-	}
-	return 0;
+#define QUEUE_WEIGHT_SET(port, ctl) \
+{ \
+	MAC##port##_PRI_CTRL_REG &= ~(0x3ffff); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.sch_mode << 16); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q0_w); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q1_w << 4); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q2_w << 8); \
+	MAC##port##_PRI_CTRL_REG |= (ctl.q3_w << 12); \
+}
+
+#define QUEUE_WEIGHT_GET(port, ctl) \
+{ \
+	ctl.sch_mode = ((MAC##port##_PRI_CTRL_REG >> 16 ) & 0x3); \
+	ctl.q0_w = ((MAC##port##_PRI_CTRL_REG >> 0 ) & 0x7); \
+	ctl.q1_w = ((MAC##port##_PRI_CTRL_REG >> 4 ) & 0x7); \
+	ctl.q2_w = ((MAC##port##_PRI_CTRL_REG >> 8 ) & 0x7); \
+	ctl.q3_w = ((MAC##port##_PRI_CTRL_REG >> 12 ) & 0x7); \
 }
-#endif /* CONFIG_CNS3XXX_ETHADDR_IN_FLASH */
 
 int cns3xxx_send_packet(struct sk_buff *skb, struct net_device *netdev);
 
 static int install_isr_rc = 0;
 static int rc_setup_rx_tx = 0; // rc means reference counting.
 static struct net_device *intr_netdev;
+unsigned int max_mtu    = 1500 + 18; //KH
+unsigned int dev_mtu[32];
+unsigned int rx_eor     = RX_DESC_SIZE -1;
+unsigned int tx_eor     = TX_DESC_SIZE -1;
+unsigned int rx_base    = 0; //KH
+unsigned int tx_base    = 0; //KH
 struct net_device *net_dev_array[NETDEV_SIZE]; 
 spinlock_t tx_lock;
 spinlock_t rx_lock;
-
-#ifdef CONFIG_FAST_BRIDGE
-static u8 fast_bridge_en = 0;
-#endif
-
-const int MAX_RX_DESC_SIZE = 512;
-const int MAX_TX_DESC_SIZE = 512;
-int RX_DESC_SIZE = 128;
-int TX_DESC_SIZE = 120;
-module_param(RX_DESC_SIZE, int, 0);
-module_param(TX_DESC_SIZE, int, 0);
-
-static u8 tx_ring_index = 0; // 0 or 1
-
-#ifdef CNS3XXX_DELAYED_INTERRUPT
-static u32 max_pend_int_cnt=MAX_PEND_INT_CNT, max_pend_time=MAX_PEND_TIME;
-#endif
+u8 fast_bridge_en=1;
+u8 show_rx_proc=0;
+u8 show_tx_proc=0;
+u8 ring_index=0; // 0 or 1
 
 #ifdef CONFIG_CNS3XXX_NAPI
 struct net_device *napi_dev;
@@ -159,6 +105,17 @@
 	#endif
 #endif
 
+const u32 MAX_RX_DESC_SIZE = 512;
+const u32 MAX_TX_DESC_SIZE = 512;
+CNS3XXXPrivate *intr_priv; //KH
+unsigned int intr_pmap = 0; //KH
+
+TXBuffer *tx_array[TX_DESC_SIZE]; //KH
+unsigned int tx_array_clean_index = 0; //KH
+unsigned int tx_array_index       = 0; //KH
+RXBuffer *rx_array[RX_DESC_SIZE]; //KH
+unsigned int rx_array_index       = 0; //KH
+
 // only for debug (proc)
 RingInfo g_ring_info; 
 
@@ -226,35 +183,20 @@
 	skb->len -= 4; // minus 4 byte vlan tag
 }
 
-static struct sk_buff *cns3xxx_alloc_skb(void)
-{
-	struct sk_buff *skb;
-	u32 align_64;
-
-	skb = dev_alloc_skb(MAX_PACKET_LEN + 2 + RX_SDP_ALIGN);
-
-	if (unlikely(!skb)) {
-		/* don't show this message for to ease off system loading */
-#if 0 
-		printk("\n dev_alloc_skb fail!! while allocate RFD ring !!\n");
-#endif
-		return NULL;
-	}
-//	pci_dma_sync_single_for_device(NULL, virt_to_phys(skb->data), MAX_PACKET_LEN+2+RX_SDP_ALIGN, PCI_DMA_FROMDEVICE);
-
-	//printk("skb->data: %x\n", skb->data);
-	align_64=CPU_CACHE_ALIGN((u32)skb->data);
-	//printk("align_64: %x\n", align_64);
-	//printk("align_64-(u32)skb->data = %x\n", align_64-(u32)skb->data);
-	skb_reserve(skb, align_64-(u32)skb->data);	/* 16 bytes alignment */
-
-#ifndef CNS3XXX_4N
-	skb_reserve(skb, NET_IP_ALIGN);	/* 16 bytes alignment */
-#endif
-	//printk("xxx skb->data: %x\n", skb->data);
 
-	return skb;
-}
+static inline struct sk_buff *cns3xxx_alloc_skb(void)
+   {
+      struct sk_buff *skb = dev_alloc_skb(max_mtu + 2 + RX_SDP_ALIGN);
+      unsigned int align = 0;
+      if(unlikely(!skb))
+         {
+            printk("\n dev_alloc_skb fail!! while allocate RFD ring !!\n");
+            return NULL;
+         }
+      align = CPU_CACHE_ALIGN((u32)skb->data);
+      skb_reserve(skb, align-(u32)skb->data + NET_IP_ALIGN);
+      return skb;
+   }                                                                        
 
 static int free_rx_skb(RXRing *rx_ring)
 {
@@ -263,15 +205,10 @@
         //RXDesc *rx_desc = rx_ring.rx_desc_head_vir_addr;
 
 	for (i=0 ; i < get_rx_ring_size(rx_ring) ; ++i) {
-		if (rx_buffer->skb) {
-			dma_unmap_single(NULL,
-					 rx_buffer->rx_desc->sdp,
-					 rx_buffer->rx_desc->sdl,
-					 DMA_FROM_DEVICE);
+		if (rx_buffer->rx_desc->cown==0 && rx_buffer->skb) {
 			dev_kfree_skb(rx_buffer->skb);
 			rx_buffer->skb=0;
 		}
-		++rx_buffer;
 	}
 	return 0;
 }
@@ -280,10 +217,16 @@
 {
 	int i=0;
 	RXBuffer *rx_buffer = 0;
-	RXDesc *rx_desc = 0;
-	dma_addr_t dmap;
+        RXDesc *rx_desc = 0;
+
+#ifdef NCNB_TEST
+	ncnb_buf = dma_alloc_coherent(NULL, 2*1024* get_rx_ring_size(rx_ring), &ncnb_buf_phy, GFP_KERNEL);
+	printk("NCB_BUF: %08X PHY: %08X \n", ncnb_buf, ncnb_buf_phy);
+	
+#endif
 
-	/* allocate RXDesc array */
+//	printk("... cns3xxx_setup_all_rx_resources ## ring_num : %d\n", ring_num);
+	// alloc RXDesc array
 	rx_ring->rx_desc_head_vir_addr = dma_alloc_coherent(NULL, sizeof(RXDesc) * (get_rx_ring_size(rx_ring)), &rx_ring->rx_desc_head_phy_addr, GFP_KERNEL);
 	if (!rx_ring->rx_desc_head_vir_addr) {
 		printk("rx_ring->rx_desc_head_vir_addr alloc memory fail!\n");
@@ -307,11 +250,12 @@
 	}
 
 	rx_buffer = rx_ring->head;
-	rx_desc = rx_ring->rx_desc_head_vir_addr;
-
+        rx_desc = rx_ring->rx_desc_head_vir_addr;
 	for (i=0 ; i < get_rx_ring_size(rx_ring) ; ++i, ++rx_buffer, ++rx_desc) {
 		rx_buffer->rx_desc = rx_desc;
 		rx_buffer->skb = cns3xxx_alloc_skb();
+		
+		rx_array[i] = rx_buffer; //KH
 
 		if (!rx_buffer->skb) {
 			free_rx_skb(rx_ring);
@@ -326,10 +270,11 @@
 		RXDesc tmp_rx_desc;
 
                 memset(&tmp_rx_desc, 0, sizeof(RXDesc));
-//                tmp_rx_desc.sdp = (u32)virt_to_phys(rx_buffer->skb->data);
+                tmp_rx_desc.sdp = (u32)virt_to_phys(rx_buffer->skb->data);
                 tmp_rx_desc.sdl = MAX_PACKET_LEN;
                 if (i == (get_rx_ring_size(rx_ring)-1) ){
                         tmp_rx_desc.eor = 1;
+                        rx_eor = i; //KH
                 }
                 tmp_rx_desc.fsd = 1;
                 tmp_rx_desc.lsd = 1;
@@ -338,23 +283,24 @@
 
 #else
 //		rx_buffer->rx_desc->sdp = (u32)virt_to_phys(rx_buffer->skb->data);
-		rx_buffer->rx_desc->sdl = MAX_PACKET_LEN;
+		rx_buffer->rx_desc->sdl = max_mtu;
 		if (i == (get_rx_ring_size(rx_ring)-1) ){
 			rx_buffer->rx_desc->eor = 1;
+			rx_eor = i; //KH
 		}
 		rx_buffer->rx_desc->fsd = 1;
 		rx_buffer->rx_desc->lsd = 1;
 #endif
+		rx_buffer->rx_desc->sdp = dma_map_single(NULL, rx_buffer->skb->data,max_mtu, DMA_FROM_DEVICE);
 
-		dmap = dma_map_single(NULL, rx_buffer->skb->data, MAX_PACKET_LEN, DMA_FROM_DEVICE);
-		rx_buffer->rx_desc->sdp = dmap;
 	}
-
 	rx_ring->cur_index = 0 ;
 
 	if (ring_num == 0){
 		FS_DESC_PTR0_REG = rx_ring->rx_desc_head_phy_addr;
 		FS_DESC_BASE_ADDR0_REG = rx_ring->rx_desc_head_phy_addr;
+		rx_base = rx_ring->rx_desc_head_phy_addr; //KH
+
 	} else if (ring_num == 1){
 		FS_DESC_PTR1_REG = rx_ring->rx_desc_head_phy_addr;
 		FS_DESC_BASE_ADDR1_REG = rx_ring->rx_desc_head_phy_addr;
@@ -381,8 +327,7 @@
 	tx_ring->head = kmalloc(sizeof(TXBuffer) * get_tx_ring_size(tx_ring), GFP_KERNEL);
 
 	tx_buffer = tx_ring->head;
-	tx_desc = tx_ring->tx_desc_head_vir_addr;
-
+        tx_desc = tx_ring->tx_desc_head_vir_addr;
 	for (i=0 ; i < get_tx_ring_size(tx_ring) ; ++i, ++tx_buffer, ++tx_desc) {
 		//printk("%d : ## tx_buffer %p ## tx_desc : %p\n", i, tx_buffer, tx_desc);
 		tx_buffer->tx_desc = tx_desc;
@@ -391,17 +336,37 @@
 		tx_buffer->skb = 0;
 		if (i == (get_tx_ring_size(tx_ring)-1) ){
 			tx_buffer->tx_desc->eor = 1;
+			tx_eor = i; //KH
 		}
 #ifdef CONFIG_SWITCH_BIG_ENDIAN
 		swap_tx_desc(tx_buffer->tx_desc, tx_buffer->tx_desc);
 #endif
 
+                tx_array[i] = tx_buffer;// KH
+#ifdef CNS3XXX_TX_HW_CHECKSUM 
+                tx_desc->ico = 1; 
+                tx_desc->uco = 1; 
+                tx_desc->tco = 1; 
+#else 
+                tx_desc->ico = 0; 
+                tx_desc->uco = 0; 
+                tx_desc->tco = 0; 
+#endif
+#ifdef CNS3XXX_TSTC_RING0_ISR
+                tx_desc->interrupt = 1;
+#else
+                tx_desc->interrupt = 0;
+#endif
+                tx_desc->ctv = 0;
+                tx_desc->fr  = 1;
 	}
 	tx_ring->cur_index = 0 ;
 
 	if (ring_num == 0){
 		TS_DESC_PTR0_REG = tx_ring->tx_desc_head_phy_addr;
 		TS_DESC_BASE_ADDR0_REG = tx_ring->tx_desc_head_phy_addr;
+		tx_base = tx_ring->tx_desc_head_phy_addr;//KH
+		
 	} else if (ring_num == 1){
 		TS_DESC_PTR1_REG = tx_ring->tx_desc_head_phy_addr;
 		TS_DESC_BASE_ADDR1_REG = tx_ring->tx_desc_head_phy_addr;
@@ -424,15 +389,9 @@
 
 	for (i=0 ; i < get_tx_ring_size(tx_ring) ; ++i) {
 		if (tx_buffer->skb) {
-			dma_unmap_single(NULL,
-					 tx_buffer->tx_desc->sdp,
-					 tx_buffer->tx_desc->sdl,
-					 DMA_TO_DEVICE);
-
 			dev_kfree_skb(tx_buffer->skb);
 			tx_buffer->skb = 0;
 		}
-		++tx_buffer;
 	}
 	return 0;
 }
@@ -469,6 +428,7 @@
 #endif
 
 static void pse_dma_idle(void);
+/*
 static int cns3xxx_free_rx_tx_res(CNS3XXXPrivate *priv)
 {
 	--rc_setup_rx_tx;
@@ -500,7 +460,7 @@
 	return 0;
 }
 
-static int cns3xxx_setup_rx_tx_res(CNS3XXXPrivate *priv)
+static int cns3xxx_setup_rx_tx_res_orig(CNS3XXXPrivate *priv)
 {
 	if (rc_setup_rx_tx == 0) {
 		int i;
@@ -545,36 +505,140 @@
 	++rc_setup_rx_tx;
 	return CAVM_OK;
 }
+*/
+
+//KH2
+/* ---------------------------------------------------------------------------------------------------- */
+RXRing rx_ring;
+TXRing tx_ring;
+//unsigned ring_en = 0;
+static int cns3xxx_setup_rx_tx_res(void)
+{
+      if(rc_setup_rx_tx==1){return CAVM_OK;}
+      clear_fs_dma_state(1);
+      FS_DESC_PTR0_REG       = 0;
+      FS_DESC_BASE_ADDR0_REG = 0;
+      FS_DESC_PTR1_REG       = 0;
+      FS_DESC_BASE_ADDR1_REG = 0;
+      TS_DESC_PTR0_REG       = 0;
+      TS_DESC_BASE_ADDR0_REG = 0;
+      TS_DESC_PTR1_REG       = 0;
+      TS_DESC_BASE_ADDR1_REG = 0;
+      tx_ring.max_ring_size  = TX_DESC_SIZE;
+      tx_ring.ring_size      = tx_eor+1;
+      if((cns3xxx_setup_all_tx_resources(&tx_ring,0))!=CAVM_OK){return CAVM_ERR;}
+      rx_ring.max_ring_size =  RX_DESC_SIZE;
+      rx_ring.ring_size     =  rx_eor+1;
+      if((cns3xxx_setup_all_rx_resources(&rx_ring,0))!=CAVM_OK){return CAVM_ERR;}
+      clear_fs_dma_state(0);
+      rc_setup_rx_tx = 1;
+      tx_array_index = 0;
+      rx_array_index = 0;
+      return CAVM_OK;
+}
+/*
+static int cns3xxx_free_rx_tx_res()
+{
+	if(rc_setup_rx_tx==0){return CAVM_OK;}
+    enable_port(3,0);
+    enable_rx_dma(0, 0);
+    enable_tx_dma(0, 0);
+    cns3xxx_free_all_rx_resources(&rx_ring);
+    cns3xxx_free_all_tx_resources(&tx_ring);
+    rc_setup_rx_tx = 0;
+    return 0;   
+}
+*/   
+unsigned int jbf = 0;
+static void reset_tx_rx_ring(void)
+{
+      TXBuffer *tx_buffer = 0;
+      RXBuffer *rx_buffer = 0;
+      unsigned int i  = 0;
+      unsigned int do_reset = 0;
+      //get the max_mtu
+      max_mtu = 0;
+      
+
+      rx_array_index = 0;
+      tx_array_index = 0;
+
+      for(i=0;i<=16;i++){if(dev_mtu[i] > max_mtu){max_mtu = dev_mtu[i];}}
+      max_mtu += 18;
+      printk("max mtu = %d\n",max_mtu);
+
+      if(max_mtu>1518&&jbf==0 ){do_reset=1;jbf=1;}
+      if(max_mtu<=1518&&jbf==1){do_reset=1;jbf=0;}
+
+      if(!do_reset){return;}
+      printk("reset tx/rx ring ..\n");
+      clear_fs_dma_state(1);
+      for(i=0;i<=tx_eor;i++)
+         {
+            tx_buffer                = tx_array[i];
+            tx_buffer->tx_desc->cown = 1;
+            tx_buffer->tx_desc->eor  = 0;
+            tx_buffer->skb           = 0;
+#ifdef CNS3XXX_TX_HW_CHECKSUM 
+            tx_buffer->tx_desc->ico  = 1; 
+            tx_buffer->tx_desc->uco  = 1; 
+            tx_buffer->tx_desc->tco  = 1; 
+#else 
+            tx_buffer->tx_desc->ico  = 0; 
+            tx_buffer->tx_desc->uco  = 0; 
+            tx_buffer->tx_desc->tco  = 0; 
+#endif
+            tx_buffer->tx_desc->interrupt =0;
+            tx_buffer->tx_desc->ctv  = 0;
+            tx_buffer->tx_desc->fr   = 1;
+         }
+      TS_DESC_PTR0_REG        = tx_ring.tx_desc_head_phy_addr;
+      TS_DESC_BASE_ADDR0_REG  = tx_ring.tx_desc_head_phy_addr;
+      tx_buffer               = tx_array[tx_eor];
+      tx_buffer->tx_desc->eor = 1;
+      tx_ring.ring_size       = tx_eor + 1;
+      //RX
+      for(i=0;i<=rx_eor;i++)
+         {
+            rx_buffer                = rx_array[i];
+            if(rx_buffer->skb){dev_kfree_skb(rx_buffer->skb);}
+            rx_buffer->skb = cns3xxx_alloc_skb();
+            rx_buffer->rx_desc->cown = 0;
+            rx_buffer->rx_desc->eor  = 0;
+            rx_buffer->rx_desc->sdl  = max_mtu;
+            rx_buffer->rx_desc->sdp  = dma_map_single(NULL, rx_buffer->skb->data,max_mtu, DMA_FROM_DEVICE);
+            rx_buffer->rx_desc->fsd  = 1;
+            rx_buffer->rx_desc->lsd  = 1;
+         }
+      FS_DESC_PTR0_REG        = rx_ring.rx_desc_head_phy_addr;
+      FS_DESC_BASE_ADDR0_REG  = rx_ring.rx_desc_head_phy_addr;      
+      rx_buffer               = rx_array[rx_eor];
+      rx_buffer->rx_desc->eor = 1;
+      rx_ring.ring_size       = rx_eor+1;
+      
+      clear_fs_dma_state(0);
+      
+}
+/* ---------------------------------------------------------------------------------------------------- */
 
-static int free_tx_desc_skb(TXRing *tx_ring, u8 ring_num)
+int free_tx_desc_skb(TXRing *tx_ring, u8 ring_num)
 {
-	int i;
+#if 1
+	int i=0;
 	//u32 tssd_current=0;
-	TXBuffer *tx_buffer;
+	TXBuffer *tx_buffer = 0;
 	u32 tx_ring_size = get_tx_ring_size(tx_ring);
 	// check curent hw index previous tx descriptor
 	u32 cur_index = cns3xxx_get_tx_hw_index(ring_num) - 1; 
-	TXDesc *tx_desc_ptr;
-#ifdef CONFIG_SWTICH_BIG_ENDIAN
-	TXDesc tmp_tx_desc;
-#endif
-	
-	tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
 
+        tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+
+
+	//while (1) 
 	for (i=0 ; i < tx_ring_size ; ++i) {
 		//printk("cur_index : %d\n", cur_index);
 		if (tx_buffer->tx_desc->cown == 1 && tx_buffer->skb) {
 			//printk("tx_buffer: %p ## free skb\n", tx_buffer);
-#ifdef CONFIG_SWTICH_BIG_ENDIAN
-			tx_desc_ptr = &tmp_tx_desc;
-			swap_tx_desc(tx_buffer->tx_desc, tx_desc_ptr);
-#else
-			tx_desc_ptr = tx_buffer->tx_desc;
-#endif
-			dma_unmap_single(NULL,
-					 tx_desc_ptr->sdp,
-					 tx_desc_ptr->sdl,
-					 DMA_TO_DEVICE);
 			dev_kfree_skb_any(tx_buffer->skb);
 			tx_buffer->skb=0;
 			//tx_buffer->tx_desc->cown == 1;
@@ -585,8 +649,10 @@
 		//printk("tssd_index: %d\n", tssd_index);
 		// --tx_desc_pair_ptr
 		--cur_index;
-		tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+        	tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+		
 	}
+#endif
 	return 0;
 }
 
@@ -594,9 +660,9 @@
 {
 }
 
-static void assign_netdev(RXBuffer volatile *rx_buffer)
+inline void assign_netdev(RXBuffer volatile *rx_buffer)
 {
-	RXDesc *rx_desc=0;
+	RXDesc * rx_desc=0;
 #ifdef CONFIG_SWITCH_BIG_ENDIAN
 	RXDesc tmp_rx_desc;
 
@@ -606,32 +672,58 @@
 	rx_desc = rx_buffer->rx_desc;
 #endif
 
-#ifndef CNS3XXX_VLAN_8021Q
-	if (is_config_cns3xxx_port_base()) {
-#endif
-		switch (rx_desc->sp) {
-		/* 
-		 * sp: the source port of the extracted packet,
-		 *	0 - mac port 0
-		 *	1 - mac port 1
-		 *	4 - mac port 2
-		 */
+//#if defined(CONFIG_CNS3XXX_PORT_BASE) || defined(CNS3XXX_VLAN_8021Q)
+#if defined(CNS3XXX_VLAN_8021Q)
+	// sp:
+	// 0 - mac port 0
+	// 1 - mac port 1
+	// 4 - mac port 2
+
+	switch (rx_desc->sp)
+	{
 		case 0:
+		{
 			rx_buffer->skb->dev = PORT0_NETDEV;
 			break;
+		}
 		case 1:
+		{
 			rx_buffer->skb->dev = PORT1_NETDEV;
 			break;
+		}
 		case 4:
+		{
 			rx_buffer->skb->dev = PORT2_NETDEV;
 			break;
-		/*FIXME: need to add exception handler*/
+		}
+
+	}
+#else
+	if(is_config_cns3xxx_port_base()) {
+		switch (rx_desc->sp)
+		{
+			case 0:
+			{
+				rx_buffer->skb->dev = PORT0_NETDEV;
+				break;
+			}
+			case 1:
+			{
+				rx_buffer->skb->dev = PORT1_NETDEV;
+				break;
+			}
+			case 4:
+			{
+				rx_buffer->skb->dev = PORT2_NETDEV;
+				break;
+			}
 
 		}
-#ifndef CNS3XXX_VLAN_8021Q
 	}
 #endif
-	if (is_config_cns3xxx_vlan_base()) {
+
+	if(is_config_cns3xxx_vlan_base())
+	{
 		u16 vlan_tag;
 
 		vlan_tag = rx_desc->c_vid;
@@ -649,162 +741,158 @@
 #endif
 #endif
 
-
-#if defined (CONFIG_CNS3XXX_SPPE)
-#define CNS3XXX_SPPE_PCI_FP_DEBUG
-static int sppe_pcie_to_wan_fastpath(struct sk_buff *skb)
+// old_priv has ring index information, current version only uses the information.
+static int cns3xxx_get_rfd_buff(RXBuffer volatile *rx_buffer, CNS3XXXPrivate *old_priv)
 {
-	SPPE_PARAM param;
-	int pci_dev_index;
-	struct iphdr *iph;
-#if defined (CONFIG_PPPOE)
-	struct ethhdr *ethh;
-
-	ethh = (struct ethhdr *)(skb->data);
-	if (ntohs(ETH_P_PPP_SES) == ethh->h_proto) {
-		/* Remove PPPoE Header */
-		memmove(skb->data+8, skb->data, 12); 
-		skb->data+=8; 
-		skb->len-=8;
-		ethh = (struct ethhdr *)(skb->data);
-		ethh->h_proto = htons(ETH_P_IP);
-	}
-#endif
-
-	iph = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
-
-	memset(&param, 0, sizeof(SPPE_PARAM));
-	param.cmd = SPPE_CMD_ARP;
-	param.op = SPPE_OP_GET;
-	param.data.sppe_arp.ip[0] = iph->daddr;
-
-	if (SPPE_RESULT_SUCCESS != sppe_func_hook(&param)) {
-#ifdef CNS3XXX_SPPE_PCI_FP_DEBUG
-		printk("<%s>read arp fail\n", __FUNCTION__);
-#endif
-		return (-1);
-	} else {
-		pci_dev_index = param.data.sppe_arp.unused_1;
-	}
+	CNS3XXXPrivate *priv=0;
+	//RXDesc volatile *rxdesc_ptr = rx_buffer->rx_desc;
+	struct sk_buff *skb;
+	//unsigned char *data;
+	u32 len;
+	RXDesc *rx_desc;
+//	u8 *data_ptr; //KH: unused variable 
 
-	param.cmd = SPPE_CMD_PCI_FP_DEV;
-	param.op = SPPE_OP_GET;
-	param.data.sppe_pci_fp_dev.dev = NULL;
-	param.data.sppe_pci_fp_dev.index = pci_dev_index;
+#ifdef CONFIG_SWITCH_BIG_ENDIAN
 
-	if (SPPE_RESULT_SUCCESS != sppe_pci_fp_hook(&param)) {
-#ifdef CNS3XXX_SPPE_PCI_FP_DEBUG
-		printk("<%s>get dev fail\n", __FUNCTION__);
-#endif
-		return (-1);
-	} else {
-		skb->dev = param.data.sppe_pci_fp_dev.dev;
-	}
+	RXDesc tmp_rx_desc;
 
-	dev_queue_xmit(skb);
+        rx_desc = &tmp_rx_desc;
+        swap_rx_desc(rx_buffer->rx_desc, rx_desc);
 
-return 0;
-}
+#else
+        rx_desc = rx_buffer->rx_desc;
 #endif
 
-// old_priv has ring index information, current version only uses the information.
-static int cns3xxx_get_rfd_buff(RXDesc *rx_desc, RXBuffer volatile *rx_buffer, CNS3XXXPrivate *old_priv)
-{
-	CNS3XXXPrivate *priv;
-	struct sk_buff *skb;
-	u32 len;
-
+	//rxdesc_ptr = rxring.vir_addr + index;
 	skb = rx_buffer->skb;
 	len = rx_desc->sdl;
 
+
 #ifdef DEBUG_RX
 	if (MSG_LEVEL == DUMP_RX_PKT_INFO) {
 		printk("rx\n");
 		print_packet(skb->data, len);	
 	}
+	
 #endif
 
-	dma_unmap_single(NULL,
-		 rx_desc->sdp,
-		 rx_desc->sdl,
-		 DMA_FROM_DEVICE);
-
-//	pci_dma_sync_single_for_device(NULL, virt_to_phys(skb->data), len, PCI_DMA_FROMDEVICE);
-
+	pci_dma_sync_single_for_device(NULL, virt_to_phys(skb->data), len, PCI_DMA_FROMDEVICE);
 #if defined (CONFIG_CNS3XXX_SPPE)
-	if (PACKET_REASON_TO_CPU == rx_desc->hr) {
+	if (PACKET_REASON_TO_CPU == rx_buffer->rx_desc->hr) {
 		if (sppe_pci_fp_ready) {
+			SPPE_PARAM param;
+			int pci_dev_index;
+			struct iphdr *iph;
+	
 			skb_put(skb, len);
-			if (0 == sppe_pcie_to_wan_fastpath(skb)) {
-				return 0;
+			iph = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
+
+			memset(&param, 0, sizeof(SPPE_PARAM));
+			param.cmd = SPPE_CMD_ARP;
+			param.op = SPPE_OP_GET;
+			param.data.sppe_arp.ip[0] = iph->daddr;
+			if (SPPE_RESULT_SUCCESS != sppe_func_hook(&param)) {
+				printk("<%s>read arp fail\n", __FUNCTION__);
+				goto NOT_IN_PCI_FP;
+			} else {
+				pci_dev_index = param.data.sppe_arp.unused_1;
+			}
+			param.cmd = SPPE_CMD_PCI_FP_DEV;
+			param.op = SPPE_OP_GET;
+			param.data.sppe_pci_fp_dev.dev = NULL;
+			param.data.sppe_pci_fp_dev.index = pci_dev_index;
+			if (SPPE_RESULT_SUCCESS != sppe_pci_fp_hook(&param)) {
+				printk("<%s>get dev fail\n", __FUNCTION__);
+				goto NOT_IN_PCI_FP;
+			} else {
+				skb->dev = param.data.sppe_pci_fp_dev.dev;
 			}
+			#if 1
+			dev_queue_xmit(skb);
+			#else
+			skb->dev->hard_start_xmit(skb, skb->dev);
+			#endif
+
+			return 0;
 		}
-		goto freepacket; /* We drop this packet */
 	}
+NOT_IN_PCI_FP:
+	/*printk("hr: %x ## sp: %d\n", rx_desc->hr, rx_desc->sp);*/
 #endif
 
-#if defined (CONFIG_CPU_FREQ)
-	if (unlikely(atomic_read(&cpufreq_pse_flag)))
-		goto freepacket;	
+#ifdef CNS3XXX_NON_NIC_MODE_8021Q
+	if (cns3xxx_is_untag_packet(rx_desc) == 1)
+		take_off_vlan_header(skb);
 #endif
-
-	if (is_cns3xxx_non_nic_mode_8021q()) {
-		if (cns3xxx_is_untag_packet(rx_desc) == 1)
-			__take_off_vlan_header(skb);
-	}
 	
-	if (is_config_cns3xxx_port_base()) {
-		assign_netdev(rx_buffer);
+#ifdef CONFIG_CNS3XXX_PORT_BASE
+	assign_netdev(rx_buffer);
 
-		if (rx_buffer->skb->dev) // if skb->dev is 0, means VLAN base
-			goto determine_dev_ok;
-	}
+	if (rx_buffer->skb->dev) // if skb->dev is 0, means VLAN base
+		goto determine_dev_ok;
+
+#endif /* CONFIG_CNS3XXX_PORT_BASE */
 
-	if (is_config_cns3xxx_vlan_base()) {
 
-		if (is_config_have_vlan_tag()) {
+#ifdef CONFIG_CNS3XXX_VLAN_BASE
+
+#ifdef CONFIG_HAVE_VLAN_TAG
 
 #if defined(CNS3XXX_VLAN_8021Q)
 	//printk("rx CNS3XXX_VLAN_8021Q\n");
 	// some funcion need netdev like eth_type_trans(), so need to assign it.
-			skb->dev = intr_netdev;
+	skb->dev = intr_netdev;
 	// 8021Q module will determine right netdev by vlan tag.
 #else  // defined(CNS3XXX_VLAN_8021Q)
-			assign_netdev(rx_buffer);
-
-			__take_off_vlan_header(skb);
+	{ 
+		assign_netdev(rx_buffer);
 
-#ifdef DEBUG_RX
-			if (MSG_LEVEL == 5)
-				print_packet(skb->data, 32);
-#endif
+		take_off_vlan_header(skb);
+		if (MSG_LEVEL == 5)
+			print_packet(skb->data, 32);
 
-			if (rx_buffer->skb->dev == 0){
-				goto freepacket;
-			}
-#endif // CNS3XXX_VLAN_8021Q
+		if ( rx_buffer->skb->dev == 0){
+			goto freepacket;
 		}
 	}
+	
+#endif // CNS3XXX_VLAN_8021Q
+
+#else  /* CONFIG_HAVE_VLAN_TAG */
+
+#ifdef CNS3XXX_RX_DESC_VLAN_INFO
+// get VLAN information by RX descriptor field
+
+#endif
+
+#endif // CONFIG_HAVE_VLAN_TAG
+
+#endif // CONFIG_CNS3XXX_VLAN_BASE
+
 
+#ifdef CONFIG_CNS3XXX_PORT_BASE
 determine_dev_ok:
+#endif
+
 	skb_put(skb, len);
 
 	if (skb->dev) {
 		priv = netdev_priv(skb->dev);
-	} else {
+	}
+	else{
 		DEBUG_MSG(WARNING_MSG, "skb_ptr->dev==NULL\n");
 		goto freepacket;
 	}
 
 #ifdef CNS3XXX_RX_HW_CHECKSUM
-	if (priv->rx_en==1) {
-	
-		switch (rx_desc->prot) {
-		case 1:	/* IPv4H5NF & UDP */
-		case 2: /* IPv4H5NF & TCP */
-		case 5: /* IPv6NENF & UDP */
-		case 6:	/* IPv6NENF & TCP */
-			if ( rx_desc->l4f == 0 && rx_desc->ipf == 0) { // tcp/udp checksum is correct
+	switch (rx_desc->prot)
+	{
+		case 1 :
+		case 2 :
+		case 5 :
+		case 6 :
+		{
+			if ( rx_desc->l4f == 0) { // tcp/udp checksum is correct
 				skb->ip_summed = CHECKSUM_UNNECESSARY;
 				//printk("CHECKSUM_UNNECESSARY\n");
 			} else {
@@ -812,47 +900,63 @@
 				//printk("CHECKSUM_NONE\n");
 			}
 			break;
+		}
 		default:
+		{
 			skb->ip_summed = CHECKSUM_NONE; 
-			//printk("rx_desc->prot: %x\n", rx_desc->prot);
+			//printk("xx CHECKSUM_NONE\n");
 			break;
 		}
-	} else {
-		skb->ip_summed = CHECKSUM_NONE; 
 	}
 #else
 	skb->ip_summed = CHECKSUM_NONE; 
 #endif // CNS3XXX_RX_HW_CHECKSUM
+
+
+	// this line must, if no, packet will not send to network layer
+#ifdef CONFIG_FAST_BRIDGE
+	if (fast_bridge_en == 0) 
+#endif
+	skb->protocol = eth_type_trans(skb, skb->dev);
 	
 	skb->dev->last_rx = jiffies;
 	priv->stats.rx_packets++;
 	priv->stats.rx_bytes += len;
 
 #ifdef CONFIG_FAST_BRIDGE
-    /* fast-bridge is for debug purpose
-	 * it just receive a packet and send it out here.
-	 */
-	if (1 == fast_bridge_en) { 
-		skb->ip_summed = CHECKSUM_NONE;
-		if (skb->dev == PORT0_NETDEV) {
-			skb->dev = PORT2_NETDEV;
-		} else if (skb->dev == PORT2_NETDEV) {
-			skb->dev = PORT0_NETDEV;
-		} else {
-			goto not_fast_bridge;
-		}    
-		cns3xxx_send_packet(skb, skb->dev);
-		return 0;
-	}    
-not_fast_bridge:
-#endif /* CONFIG_FAST_BRIDGE */
+	if (fast_bridge_en == 1) {
 
-    skb->protocol = eth_type_trans(skb, skb->dev);
+        skb->ip_summed = CHECKSUM_NONE;
+	if ( skb->dev == PORT0_NETDEV) {
+		skb->dev = PORT1_NETDEV;
+	} else if ( skb->dev == PORT1_NETDEV) {
+		skb->dev = PORT0_NETDEV;
+	}
+       	//skb->dev->hard_start_xmit(skb, skb->dev);
+	cns3xxx_send_packet(skb, skb->dev);
+	} else {
+#endif // #ifdef CONFIG_FAST_BRIDGE
 
-#ifdef CONFIG_CNS3XXX_NAPI
-	netif_receive_skb(skb);
+
+//#if defined(CNS3XXX_VLAN_8021Q)
+#if 0
+	if (priv->vlgrp != NULL)
+	{
+		//cns3xxx_vlan_rx(priv, skb, rx_buffer->rx_desc->c_vid);
+		cns3xxx_vlan_rx(priv, skb, rx_buffer->rx_desc->c_vid);
+		//cns3xxx_vlan_rx(priv, skb, swab16(le32_to_cpu(rx_buffer->rx_desc->c_vid)) );
+	}
+	else
 #else
+	#ifdef CONFIG_CNS3XXX_NAPI
+	netif_receive_skb(skb);
+	#else
 	netif_rx(skb);
+	#endif
+#endif
+
+#ifdef CONFIG_FAST_BRIDGE
+	}
 #endif
 
 	//vlan_hwaccel_receive_skb(skb, priv->vlgrp, 1);
@@ -866,7 +970,7 @@
 }
 
 // index from 1
-u32 get_rx_hw_index(CNS3XXXPrivate *priv)
+inline u32 get_rx_hw_index(CNS3XXXPrivate *priv)
 {
 	printk("get_rx_head_phy_addr(&RX_RING0(priv): %x\n", get_rx_head_phy_addr(&RX_RING0(priv)) );
 	printk("FS_DESC_PTR0_REG: %x\n", FS_DESC_PTR0_REG);
@@ -874,7 +978,7 @@
 	return ((FS_DESC_PTR0_REG - get_rx_head_phy_addr(&RX_RING0(priv))) / sizeof(RXDesc) );
 }
 
-int get_rx_hw_index_by_reg(u8 ring_num)
+inline int get_rx_hw_index_by_reg(u8 ring_num)
 {
 	if (ring_num == 0 ) {
 		return ((FS_DESC_PTR0_REG - FS_DESC_BASE_ADDR0_REG) / sizeof(RXDesc) );
@@ -903,18 +1007,15 @@
 #endif
 {
 	int fssd_index;
-	RXBuffer volatile *rx_buffer;
-	RXDesc volatile *rx_desc;
+	//int fssd_current;
+	RXBuffer volatile *rx_buffer = 0;
+	RXDesc volatile *rx_desc=0;
 	struct sk_buff *skb;
 #ifndef CONFIG_CNS3XXX_NAPI
 	int fsqf = 0; // Queue Full Mode =0
 #endif
 	int i, rxcount = 0;
 	u8 queue_index = priv->ring_index;
-	dma_addr_t dmap;
-
-	RXDesc volatile *rx_desc_ori_ptr;
-	volatile RXDesc rx_desc_tmp;
 
 #ifdef CONFIG_SWITCH_BIG_ENDIAN
 	RXDesc tmp_rx_desc;
@@ -923,10 +1024,10 @@
 	rx_buffer = get_cur_rx_buffer(&(priv->rx_ring[queue_index]));
 
 #ifdef CONFIG_SWITCH_BIG_ENDIAN
-	rx_desc = &tmp_rx_desc;
-	swap_rx_desc(rx_buffer->rx_desc, rx_desc);
+        rx_desc = &tmp_rx_desc;
+        swap_rx_desc(rx_buffer->rx_desc, rx_desc);
 #else
-	rx_desc = rx_buffer->rx_desc;
+        rx_desc = rx_buffer->rx_desc;
 #endif
 
 	fssd_index = get_rx_hw_index_by_reg(queue_index);
@@ -964,82 +1065,32 @@
 #endif
 
 	for (i = 0; i < rxcount; i++) {
-		if (rx_desc->cown != 0) { // start to get packet
-#ifdef UDP_OVERRUN_FIXUP
-			/* copy descriptor from NCNB to CB  */
-			rx_desc_ori_ptr = rx_desc;
-			rx_desc = &rx_desc_tmp;
-			rx_desc_tmp = *rx_desc_ori_ptr;
-
-			if (rx_buffer->skb) { /* receive packet when rx_buffer->skb is available */
-				cns3xxx_get_rfd_buff((RXDesc *)rx_desc, rx_buffer, priv);
-				++(*work_done);
-			}
-	
-			/* Alloc New skb_buff */
-			skb = cns3xxx_alloc_skb();
-			rx_buffer->skb = skb;
-			if (likely(skb)) { /* update rx desc if we can get new skb */
-				dmap = dma_map_single(NULL, skb->data, MAX_PACKET_LEN, DMA_FROM_DEVICE);
-				rx_desc->sdp = dmap;
-				rx_desc->sdl = MAX_PACKET_LEN;
-				rx_desc->fsd = 1;
-				rx_desc->lsd = 1;
-				rx_desc->cown = 0; 
-			}
-
-			/* write descriptor back to NCNB */
-			*rx_desc_ori_ptr = rx_desc_tmp;
-			rx_desc = rx_desc_ori_ptr;
-#ifdef CONFIG_SWITCH_BIG_ENDIAN
-			swap_rx_desc(rx_desc, rx_buffer->rx_desc);
-#endif
 
-#ifdef CONFIG_CNS3XXX_NAPI
-			if (*work_done >= work_to_do) {
-				rx_index_next(&priv->rx_ring[queue_index]); // rx_ring.cur_index points to next
-				rx_buffer = get_cur_rx_buffer(&priv->rx_ring[queue_index]);
-				rx_desc = rx_buffer->rx_desc;
-				break;
-			}
-#endif
-#else /* !UDP_OVERRUN_FIXUP */
+		if (rx_desc->cown != 0) { // start to get packet
 			// Alloc New skb_buff 
 			skb = cns3xxx_alloc_skb();
 			// Check skb_buff
 			if (skb) {
-				rx_desc_ori_ptr = rx_desc;
-				rx_desc = &rx_desc_tmp;
-				rx_desc_tmp = *rx_desc_ori_ptr;
-
-				cns3xxx_get_rfd_buff((RXDesc *)rx_desc, rx_buffer, priv);
-
+				cns3xxx_get_rfd_buff(rx_buffer, priv);
 				rx_buffer->skb = skb;
 #ifndef NCNB_TEST
-//				rx_desc->sdp = (u32)virt_to_phys(skb->data);
+				rx_desc->sdp = (u32)virt_to_phys(skb->data);
 #endif
-				dmap = dma_map_single(NULL, skb->data, MAX_PACKET_LEN, DMA_FROM_DEVICE);
-				
-				rx_desc->sdp = dmap;
-				rx_desc->sdl = MAX_PACKET_LEN;
+				rx_desc->sdl = max_mtu;
 				rx_desc->fsd = 1;
 				rx_desc->lsd = 1;
-
-				*rx_desc_ori_ptr = rx_desc_tmp;
-				rx_desc = rx_desc_ori_ptr;
-
 				rx_desc->cown = 0; // set cbit to 0 
-
 #ifdef CONFIG_SWITCH_BIG_ENDIAN
-				swap_rx_desc(rx_desc, rx_buffer->rx_desc);
+                                swap_rx_desc(rx_desc, rx_buffer->rx_desc);
 #endif
 
 #ifdef CONFIG_CNS3XXX_NAPI
 				++(*work_done);
 				if (*work_done >= work_to_do) {
-					rx_index_next(&priv->rx_ring[queue_index]); // rx_ring.cur_index points to next
-					rx_buffer = get_cur_rx_buffer(&priv->rx_ring[queue_index]);
-					rx_desc = rx_buffer->rx_desc;
+
+		rx_index_next(&priv->rx_ring[queue_index]); // rx_ring.cur_index points to next
+		rx_buffer = get_cur_rx_buffer(&priv->rx_ring[queue_index]);
+		rx_desc = rx_buffer->rx_desc;
 					break;
 				}
 #endif
@@ -1054,12 +1105,8 @@
 #endif
 				return;
 			}
-#endif /* #ifdef UDP_OVERRUN_FIXUP */
 		} else { // cown is 0, no packets
 			//*work_done = 0;
-#ifdef CONFIG_SWITCH_BIG_ENDIAN
-			swap_rx_desc(rx_desc, rx_buffer->rx_desc);
-#endif
 			return;
 		}
 
@@ -1083,9 +1130,15 @@
 
 irqreturn_t cns3xxx_fsrc_ring0_isr(int irq, void *dev_id)
 {
+	struct net_device *netdev = dev_id;
+	CNS3XXXPrivate *priv = netdev_priv(netdev);
+
+	priv->ring_index=0;
+
 #ifdef CONFIG_CNS3XXX_NAPI
+{
 	CNS3XXXPrivate *priv = netdev_priv(napi_dev);
-	priv->ring_index = 0;
+	priv->ring_index=0;
 
 #ifdef CNS3XXX_USE_MASK
 	cns3xxx_write_pri_mask(0xb0);
@@ -1093,21 +1146,19 @@
 	cns3xxx_disable_irq(FSRC_RING0_INTERRUPT_ID);
 #endif
 
-	if (likely(napi_schedule_prep(&priv->napi))) {
-		__napi_schedule(&priv->napi);
+        //if (likely(netif_rx_schedule_prep(napi_dev, &priv->napi))) {
+        if (likely(napi_schedule_prep(&priv->napi))) {
+                //__netif_rx_schedule(napi_dev, &priv->napi);
+                __napi_schedule(&priv->napi);
 	} else {
 #ifdef CNS3XXX_USE_MASK
 		cns3xxx_write_pri_mask(0xf0);
 #else
-		cns3xxx_enable_irq(FSRC_RING0_INTERRUPT_ID);
+                cns3xxx_enable_irq(FSRC_RING0_INTERRUPT_ID);
 #endif
-	}
-
-#else /* !CONFIG_CNS3XXX_NAPI */
-	struct net_device *netdev = dev_id;
-	CNS3XXXPrivate *priv = netdev_priv(netdev);
-
-	priv->ring_index = 0;
+        }
+}
+#else // !CONFIG_CNS3XXX_NAPI
 
 #ifdef CNS3XXX_USE_MASK
 	cns3xxx_write_pri_mask(0xb0);
@@ -1139,16 +1190,18 @@
 	priv->ring_index=1;
 
 #if defined(CONFIG_CNS3XXX_NAPI) && defined(CNS3XXX_DOUBLE_RX_RING)
-	priv = netdev_priv(r1_napi_dev);
-	priv->ring_index = 1;
+{
+	CNS3XXXPrivate *priv = netdev_priv(r1_napi_dev);
+	priv->ring_index=1;
 
 	cns3xxx_disable_irq(FSRC_RING1_INTERRUPT_ID);
 
-	if (likely(napi_schedule_prep(&priv->napi))) {
-		__napi_schedule(&priv->napi);
+        if (likely(napi_schedule_prep(&priv->napi))) {
+                __napi_schedule(&priv->napi);
 	} else {
-		cns3xxx_enable_irq(FSRC_RING1_INTERRUPT_ID);
-	}
+                cns3xxx_enable_irq(FSRC_RING1_INTERRUPT_ID);
+        }
+}
 #else
 
 	cns3xxx_disable_irq(CNS3XXX_FSRC_RING1_INTERRUPT_ID);
@@ -1164,46 +1217,45 @@
 }
 #endif
 
-#ifndef CNS3XXX_SG_DISABLE
-static int cns3xxx_check_enough_tx_descriptor(TXRing *tx_ring, int need_free_tx_desc)
+int cns3xxx_check_enough_tx_descriptor(TXRing *tx_ring, int need_free_tx_desc)
 {
-	int i=0;
-	TXDesc *tx_desc=0;
-	u32 cur_index = get_tx_cur_index(tx_ring);
-	TXBuffer *tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
+#if 1
+        int i=0;
+        TXDesc *tx_desc=0;
+        u32 cur_index = get_tx_cur_index(tx_ring);
+        TXBuffer *tx_buffer = get_tx_buffer_by_index(tx_ring, cur_index);
 
 #ifdef CONFIG_SWITCH_BIG_ENDIAN
-	TXDesc tmp_tx_desc;
-	tx_desc = &tmp_tx_desc;
-	swap_tx_desc(tx_buffer->tx_desc, tx_desc);
+        TXDesc tmp_tx_desc;
+        tx_desc = &tmp_tx_desc;
+        swap_tx_desc(tx_buffer->tx_desc, tx_desc);
 #else
-	tx_desc = tx_buffer->tx_desc;
+        tx_desc = tx_buffer->tx_desc;
 #endif
-     
-	for (i=0 ; i < need_free_tx_desc ; ++i) {
-		if ( tx_desc->cown == 0 ) {
-			return 0; // no free TX descriptor
-		}
-		tx_buffer = get_tx_buffer_by_index(tx_ring, ++cur_index);
-#ifdef CONFIG_SWITCH_BIG_ENDIAN
-		tx_desc = &tmp_tx_desc;
-		swap_tx_desc(tx_buffer->tx_desc, tx_desc);
-#else
-		tx_desc = tx_buffer->tx_desc;
+
+
+        for (i=0 ; i < need_free_tx_desc ; ++i) {
+                if ( tx_desc->cown == 0 ) {
+                        return 0; // no free TX descriptor
+                }
+                tx_buffer = get_tx_buffer_by_index(tx_ring, ++cur_index);
+        }
 #endif
-	}
-	return 1;
+        return 1;
 }
-#endif
 
 // if return CAVM_ERR, means pad is fail, the packet cannot send by switch.
-static int fill_a_skb_to_tx_desc(TXBuffer *tx_buffer, u8 *data, int len, struct sk_buff *skb, const struct CNS3XXXPrivate_ *priv, int sg, int fsd, int lsd)
+#if 0
+static int fill_a_skb_to_tx_desc(TXBuffer * tx_buffer, u8 *data, int len, struct sk_buff *skb, const struct CNS3XXXPrivate_ *priv, int sg, int fsd, int lsd)
 {
-	TXDesc *tx_desc_ptr = 0;
-	TXDesc *tx_desc_ori_ptr = 0;
+	//TXDesc *tx_desc_ptr = tx_buffer->tx_desc;
+	//	static int tt=0;
+	register dma_addr_t dmap;
+	register TXRing *tx_ring;
+
+	register TXDesc *tx_desc_ptr = 0;
+	register TXDesc *tx_desc_ori_ptr = 0;
 	TXDesc tx_desc_tmp;
-	
-	dma_addr_t dmap;
   
 #ifdef CONFIG_SWTICH_BIG_ENDIAN
 	TXDesc tmp_tx_desc;
@@ -1223,14 +1275,18 @@
 				tx_desc_ptr->sdl,
 				DMA_TO_DEVICE);
 		dev_kfree_skb_any(tx_buffer->skb); 
+		tx_buffer->skb = 0 ;
+		//printk("xx tx_ring cur index: %d\n", tx_ring.cur_index);
+	} else { 
+		//++tx_ring.non_free_tx_skb; 
+		//printk("yy tx_ring cur index: %d\n", tx_ring.cur_index);
 	} 
 
 	tx_buffer->skb = skb;  /* for free skb */ 
-	//tx_desc_ptr->sdp = virt_to_phys(data);
-	/* FIXME:*/ 
-#if 0
+	//tx_desc_ptr->sdp = virt_to_phys(data); 
+	//tx_buffer->j = tt;
 	tx_buffer->tx_index = cns3xxx_get_tx_hw_index(0);
-#endif
+	//++tt;
 
 #ifdef CNS3XXX_TX_HW_CHECKSUM 
 	tx_desc_ptr->ico = 1; 
@@ -1247,9 +1303,7 @@
 #else
 	tx_desc_ptr->interrupt = 0;
 #endif
-
-	/* move packet length check to outside of this */
-#if 0
+ 
 	/* fill 0 to MIN_PACKET_LEN size */ 
 	// can change MIN_PACKET_LEN to 14
 	
@@ -1268,9 +1322,6 @@
 	} else { 
 		tx_desc_ptr->sdl = len; 
 	} 
-#else
-	tx_desc_ptr->sdl = len; 
-#endif
 
 	//dma_cache_maint(data, tx_desc_ptr->sdl, PCI_DMA_TODEVICE); 
 	dmap = dma_map_single(NULL, data, len, DMA_TO_DEVICE);
@@ -1300,144 +1351,323 @@
 	swap_tx_desc(tx_desc_ptr, tx_buffer->tx_desc);
 #endif
 
-	return CAVM_OK;
-} 
-
-int cns3xxx_send_packet(struct sk_buff *skb, struct net_device *netdev)
-{
-	CNS3XXXPrivate *priv = netdev_priv(netdev);
-	TXBuffer *tx_buffer;
-	unsigned long flags;
-#ifndef CNS3XXX_SG_DISABLE
-	int nr_frags = skb_shinfo(skb)->nr_frags;
-#endif
-	TXRing *tx_ring;
-
-	spin_lock_irqsave(&tx_lock, flags);
-
-	/* 
-	 * 1. PSE min packet length is MIN_PACKET_LEN (14)
-	 * 2. packet length < 14 byte is impossible in real world,
-	 * following check is just for hardware protection 
- 	 */
-	if (unlikely(MIN_PACKET_LEN > skb->len)) {
-		dev_kfree_skb_any(skb); 
-		spin_unlock_irqrestore(&tx_lock, flags);
-		return NETDEV_TX_OK;
-	}
+	tx_ring = priv->tx_ring + ring_index;
 
-#if defined (CONFIG_CPU_FREQ)
-	if (unlikely(atomic_read(&cpufreq_pse_flag))) {
-		spin_unlock_irqrestore(&tx_lock, flags);
-		return NETDEV_TX_OK;
-	}
-#endif
+	if (tx_ring->num_free_desc)
+		tx_ring->num_free_desc--;
 
-#ifdef DEBUG_TX
-	if (MSG_LEVEL == DUMP_TX_PKT_INFO) {
-		printk("tx\n");
-		print_packet(tx_buffer->skb->data, tx_buffer->tx_desc->sdl);
-		//dump_tx_desc(tx_buffer->tx_desc);
-	}
+	return CAVM_OK;
+} 
 #endif
 
-	tx_ring = priv->tx_ring + tx_ring_index;
-
-#ifndef CNS3XXX_SG_DISABLE
-	if (cns3xxx_check_enough_tx_descriptor(tx_ring, nr_frags+1) == 0) { 
-		// no enough tx descriptor
-		spin_unlock_irqrestore(&tx_lock, flags);
-		// re-queue the skb
-		return NETDEV_TX_BUSY;
-	} 
-	tx_buffer = get_cur_tx_buffer(tx_ring);
+/* --------------------------------------------------------------------------------------------------------------- */
+int tx_buffer_check(unsigned int cnt)
+   {
+      unsigned int i =0;
+      unsigned int tx_array_index_tmp = tx_array_index;
+      TXBuffer *tx_buffer = 0;
+      TXDesc   *tx_desc   = 0;
+      for(i=0;i<=cnt;i++)
+         {
+#if 0
+            tx_array_index_tmp = (tx_array_index_tmp+1)&(TX_DESC_SIZE-1);
 #else
-	tx_buffer = get_cur_tx_buffer(tx_ring);
-
-	if (0 == tx_buffer->tx_desc->cown)
-		return NETDEV_TX_BUSY;
-#endif
-
-#ifndef CNS3XXX_SG_DISABLE
-	if (nr_frags == 0) { // non scatter/gather I/O
-#endif
-		fill_a_skb_to_tx_desc(tx_buffer, skb->data, skb->len, skb, priv, 0, 1, 1);
-		tx_index_next(tx_ring);
-#ifndef CNS3XXX_SG_DISABLE
-	} else { // scatter/gather I/O
-		struct skb_frag_struct *frag = 0;
-		TXDesc *tx_desc[MAX_SKB_FRAGS+1];
-		int tx_desc_count=0;
-		int i=0;
-	
-#ifdef CNS3XXX_SG_DEBUG
-		++sg_time;
-#endif
-
-		fill_a_skb_to_tx_desc(tx_buffer, skb->data, skb->len - skb->data_len, 0, priv, 1, 1, 0);
-		tx_desc[tx_desc_count++] = tx_buffer->tx_desc;
-		tx_index_next(tx_ring);
-		tx_buffer = get_cur_tx_buffer(tx_ring);
+            tx_array_index_tmp = (tx_array_index_tmp+1)&(tx_eor);
+#endif            
+            tx_buffer = tx_array[tx_array_index_tmp];
+            tx_desc   = tx_buffer->tx_desc;
+            if(tx_desc->cown==0){return 0;}
+         }
+      return 1;
+   }
 
-		for (i=0 ; i < nr_frags-1 ; ++i) {
-			frag = &skb_shinfo(skb)->frags[i];
-
-			fill_a_skb_to_tx_desc(tx_buffer, page_address(frag->page) + frag->page_offset, frag->size, 0, priv, 1, 0, 0);
-			tx_desc[tx_desc_count++] = tx_buffer->tx_desc;
-
-			tx_index_next(tx_ring);
-			tx_buffer = get_cur_tx_buffer(tx_ring);
-		}
-		frag = &skb_shinfo(skb)->frags[nr_frags-1];
-
-		// last fragment
-		fill_a_skb_to_tx_desc(tx_buffer, page_address(frag->page) + frag->page_offset, frag->size, skb, priv, 1, 0, 1);
-		tx_desc[tx_desc_count++] = tx_buffer->tx_desc;
+/* --------------------------------------------------------------------------------------------------------------- */
+/*
+#define write_tx_desc(m_buffer,m_skb,m_desc,m_data,m_len,m_pmap,m_fsd,m_lsd,m_cown)   \
+   {                                                                                  		\
+      if(m_buffer->skb)                                                              	\
+      {                                                                               		\
+      dev_kfree_skb(m_buffer->skb);                                             \
+      }                                                                               		\
+      m_buffer->skb        = m_skb;                                               \
+      m_desc->sdp          = virt_to_phys(m_data);                           \
+      m_desc->sdl          = m_len;                                                \
+	__dma_single_cpu_to_dev(m_data,m_len, DMA_TO_DEVICE);	\
+      m_desc->pmap         = m_pmap;                                          \
+      m_desc->fsd          = m_fsd;                                                \
+      m_desc->lsd          = m_lsd;                                                 \
+      m_desc->cown         = m_cown;                                            \
+      *(m_buffer->tx_desc) = *m_desc;                                          \
+   }
+*/
+
+void write_tx_desc(TXBuffer *m_buffer,struct sk_buff *m_skb,TXDesc   *m_desc,unsigned char *m_data,unsigned int m_len,unsigned int m_pmap,unsigned int m_fsd,unsigned int m_lsd,unsigned int m_cown)
+{
+	if(m_buffer->skb)  {
+      		dev_kfree_skb(m_buffer->skb);
+      	}  
+      	m_buffer->skb        = m_skb; 
+      	m_desc->sdp          = virt_to_phys(m_data); 
+      	m_desc->sdl          = m_len;
+#ifdef LINUX2635		
+	__dma_single_cpu_to_dev(m_data,m_len, DMA_TO_DEVICE);
+#elif LINUX2631
+	dma_cache_maint(m_data,m_len, DMA_TO_DEVICE);
+#endif
+      	m_desc->pmap         = m_pmap; 
+      	m_desc->fsd          = m_fsd; 
+      	m_desc->lsd          = m_lsd;   
+      	m_desc->cown         = m_cown;
+      	*(m_buffer->tx_desc) = *m_desc;  
+   }
 
-		tx_index_next(tx_ring);
-		tx_buffer = get_cur_tx_buffer(tx_ring);
-		
-		for (i = 0; i < tx_desc_count ; i++ )
-			tx_desc[i]->cown = 0 ; 
-	}
+/* --------------------------------------------------------------------------------------------------------------- */
+int cns3xxx_send_packet(struct sk_buff *skb, struct net_device *netdev)
+   {
+      /* --------------------------------------------------------------------------------------------------------- */
+      CNS3XXXPrivate *priv = netdev_priv(netdev);
+      TXDesc   tmp_desc; //modify by Gopal
+      TXDesc   *tx_desc; //modify by Gopal
+      unsigned int nr_frags      = skb_shinfo(skb)->nr_frags;
+      TXBuffer *tx_buffer        = 0;
+      tx_desc                    = &tmp_desc; //modify by Gopal
+	  //	unsigned long flags;
+
+	  if (skb->len < MIN_PACKET_LEN) skb_put(skb,MIN_PACKET_LEN - skb->len);
+
+      intr_pmap = priv->net_device_priv->pmap;
+      if(!nr_frags) // scatter-gather off
+         {
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_buffer             = tx_array[tx_array_index];
+            *tx_desc              = *(tx_buffer->tx_desc); //modify by Gopal
+            /* --------------------------------------------------------------------------------------------------- */            
+            if(tx_desc->cown==0){return NETDEV_TX_BUSY;}
+            /* --------------------------------------------------------------------------------------------------- */
+            write_tx_desc(tx_buffer,skb,tx_desc,skb->data,skb->len,intr_pmap,1,1,0);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_array_index        = (tx_array_index +1)&(tx_eor);
+            /* --------------------------------------------------------------------------------------------------- */
+         }
+      /* --------------------------------------------------------------------------------------------------------- */
+      else // scatter-gather on
+         {
+            /* --------------------------------------------------------------------------------------------------- */            
+            unsigned int i       = 0;
+            unsigned char *data  = 0;
+            unsigned int len     = 0;
+            struct skb_frag_struct *frag = 0;
+            unsigned int fid     = tx_array_index;
+            /* --------------------------------------------------------------------------------------------------- */            
+            if(!tx_buffer_check(nr_frags)){return NETDEV_TX_BUSY;}            
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_array_index        = (tx_array_index +1)&(tx_eor);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_buffer            = tx_array[tx_array_index];
+            *tx_desc             =  *(tx_buffer->tx_desc); //modify by Gopal
+            /* --------------------------------------------------------------------------------------------------- */
+            // frag 
+            /* --------------------------------------------------------------------------------------------------- */
+            for(i=0;i<nr_frags-1;i++)
+               {
+                  /* --------------------------------------------------------------------------------------------- */
+                  frag           = &skb_shinfo(skb)->frags[i];
+                  len            = frag->size;
+                  data           = ((void *) page_address(frag->page) + frag->page_offset);
+                  /* --------------------------------------------------------------------------------------------- */
+                  write_tx_desc(tx_buffer,0,tx_desc,data,len,intr_pmap,0,0,0);
+                  /* --------------------------------------------------------------------------------------------- */
+                  tx_array_index        = (tx_array_index +1)&(tx_eor);
+                  /* --------------------------------------------------------------------------------------------- */
+                  tx_buffer      = tx_array[tx_array_index];
+                  *tx_desc       =  *(tx_buffer->tx_desc); //modify by Gopal
+                  /* --------------------------------------------------------------------------------------------- */
+               }
+            /* --------------------------------------------------------------------------------------------------- */
+            // frag last
+            /* --------------------------------------------------------------------------------------------------- */
+            frag                 = &skb_shinfo(skb)->frags[nr_frags-1];
+            len                  = frag->size;
+            data                 = ((void *) page_address(frag->page) + frag->page_offset);
+            /* --------------------------------------------------------------------------------------------------- */
+            write_tx_desc(tx_buffer,skb,tx_desc,data,len,intr_pmap,0,1,0);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_array_index        = (tx_array_index +1)&(tx_eor);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_buffer            = tx_array[fid];
+            *tx_desc             =  *(tx_buffer->tx_desc);
+            write_tx_desc(tx_buffer,0,tx_desc,skb->data,skb->len - skb->data_len,intr_pmap,1,0,0);
+            /* --------------------------------------------------------------------------------------------------- */
+         }
+      /* --------------------------------------------------------------------------------------------------------- */
+      mb();
+      TS_DMA_CTRL0_REG           = 1; //enable_tx_dma(ring_index, 1);
+      /* --------------------------------------------------------------------------------------------------------- */
+//      intr_priv->stats.tx_packets++;
+//      intr_priv->stats.tx_bytes += skb->len;
+      priv->stats.tx_packets++;
+      priv->stats.tx_bytes += skb->len;
+      netdev->trans_start        = jiffies;
+      /* --------------------------------------------------------------------------------------------------------- */
+      return NETDEV_TX_OK;
+      /* --------------------------------------------------------------------------------------------------------- */
+   }
+/* --------------------------------------------------------------------------------------------------------------- */
+#if 0
+int cns3xxx_send_packet_nas_v01(struct sk_buff *skb, struct net_device *netdev)
+   {
+      /* --------------------------------------------------------------------------------------------------------- */
+      CNS3XXXPrivate *priv  = netdev_priv(netdev);
+      TXBuffer *tx_buffer   = tx_array[tx_array_index];
+      TXDesc   tmp_desc;                 //modify by Gopal
+      unsigned int pmap     = priv->net_device_priv->pmap;
+      unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+      TXDesc   *tx_desc;                 //modify by Gopal
+      tx_desc               = &tmp_desc; //modify by Gopal
+      *tx_desc              = *(tx_buffer->tx_desc); //modify by Gopal
+      if(!nr_frags) // scatter-gather off
+         {
+            /* --------------------------------------------------------------------------------------------------- */
+            if(tx_desc->cown==0){return NETDEV_TX_BUSY;}
+            /* --------------------------------------------------------------------------------------------------- */
+            /* --------------------------------------------------------------------------------------------------- */
+            if(tx_buffer->skb){dev_kfree_skb(tx_buffer->skb);}
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_buffer->skb        = skb;
+            tx_desc->sdp          = virt_to_phys(skb->data); 
+            tx_desc->sdl          = skb->len; 
+            /* --------------------------------------------------------------------------------------------------- */
+            __dma_single_cpu_to_dev(skb->data, tx_desc->sdl, DMA_TO_DEVICE);
+			//dma_cache_maint(skb->data, tx_desc->sdl, PCI_DMA_TODEVICE);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_desc->pmap         = pmap;
+            tx_desc->fsd          = 1;
+            tx_desc->lsd          = 1;
+            tx_desc->cown         = 0;
+            /* --------------------------------------------------------------------------------------------------- */
+            *(tx_buffer->tx_desc) = *tx_desc; //modify by Gopal
+            tx_array_index        = ( tx_array_index + 1 ) & (tx_eor);
+            /* --------------------------------------------------------------------------------------------------- */
+         }
+      /* --------------------------------------------------------------------------------------------------------- */
+      else // scatter-gather on
+         {
+            unsigned int i = 0;
+            unsigned int len = skb->len - skb->data_len;
+            unsigned char *data = skb->data;
+            struct skb_frag_struct *frag = 0;
+            TXDesc *sg_tx_desc = tx_buffer->tx_desc;
+            /* --------------------------------------------------------------------------------------------------- */            
+            if(!tx_buffer_check(nr_frags)){return NETDEV_TX_BUSY;}            
+            /* --------------------------------------------------------------------------------------------------- */            
+            if(tx_buffer->skb)
+               {
+                  dev_kfree_skb(tx_buffer->skb);
+               }
+            /* --------------------------------------------------------------------------------------------------- */            
+            // skb
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_buffer->skb        = 0;
+            tx_desc->sdp          = virt_to_phys(skb->data);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_desc->sdl          = len; 
+			__dma_single_cpu_to_dev(data,tx_desc->sdl, DMA_TO_DEVICE);
+            //dma_cache_maint(data, tx_desc->sdl, PCI_DMA_TODEVICE);
+            tx_desc->pmap         = pmap;
+            tx_desc->fsd          = 1;
+            tx_desc->lsd          = 0;
+            tx_desc->cown         = 1;
+            *(tx_buffer->tx_desc) =  *tx_desc; //modify by Gopal
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_array_index        = (tx_array_index +1)&(tx_eor);
+            tx_buffer             = tx_array[tx_array_index];
+            *(tx_desc) =  *(tx_buffer->tx_desc); //modify by Gopal
+            /* --------------------------------------------------------------------------------------------------- */
+            // frag 
+            /* --------------------------------------------------------------------------------------------------- */
+            for(i=0;i<nr_frags-1;i++)
+               {
+                  frag = &skb_shinfo(skb)->frags[i];
+                  len  = frag->size;
+                  data = ((void *) page_address(frag->page) + frag->page_offset);
+                  if(tx_buffer->skb)
+                     {
+                        dev_kfree_skb(tx_buffer->skb);
+                        tx_buffer->skb = 0;
+                     }
+                  tx_desc->sdp          = virt_to_phys(data); 
+                  tx_desc->sdl          = len; 
+				  __dma_single_cpu_to_dev(data,tx_desc->sdl, DMA_TO_DEVICE);
+                  //dma_cache_maint(data, tx_desc->sdl, PCI_DMA_TODEVICE);
+                  tx_desc->pmap         = pmap;
+                  tx_desc->fsd          = 0;
+                  tx_desc->lsd          = 0;
+                  tx_desc->cown         = 0;
+                  /* --------------------------------------------------------------------------------------------- */
+                  *(tx_buffer->tx_desc) =  *tx_desc; //modify by Gopal
+                  tx_array_index        = (tx_array_index +1)&(tx_eor);
+                  tx_buffer             = tx_array[tx_array_index];
+                  *tx_desc              =  *(tx_buffer->tx_desc); //modify by Gopal
+                  /* --------------------------------------------------------------------------------------------- */
+               }
+            /* --------------------------------------------------------------------------------------------------- */
+            // frag last
+            /* --------------------------------------------------------------------------------------------------- */
+            frag = &skb_shinfo(skb)->frags[nr_frags-1];
+            len  = frag->size;
+            data = ((void *) page_address(frag->page) + frag->page_offset);
+            if(tx_buffer->skb)
+               {
+                  dev_kfree_skb(tx_buffer->skb);
+               }
+            tx_buffer->skb        = skb;
+            tx_desc->sdp          = virt_to_phys(data);
+            /* --------------------------------------------------------------------------------------------------- */
+            tx_desc->sdl          = len; 
+			__dma_single_cpu_to_dev(data,tx_desc->sdl, DMA_TO_DEVICE);
+            dma_cache_maint(data, tx_desc->sdl, PCI_DMA_TODEVICE);
+            tx_desc->pmap         = pmap;
+            tx_desc->fsd          = 0;
+            tx_desc->lsd          = 1;
+            tx_desc->cown         = 0;
+            /* --------------------------------------------------------------------------------------------------- */
+            *(tx_buffer->tx_desc) =  *tx_desc; //modify by Gopal
+            tx_array_index        = (tx_array_index +1)&(tx_eor);
+            /* --------------------------------------------------------------------------------------------------- */
+            sg_tx_desc->cown      = 0;
+            /* --------------------------------------------------------------------------------------------------- */
+         }
+      /* --------------------------------------------------------------------------------------------------------- */
+      mb();
+      TS_DMA_CTRL0_REG      = 1; //enable_tx_dma(ring_index, 1);
+      /* --------------------------------------------------------------------------------------------------------- */
+      priv->stats.tx_packets++;
+      priv->stats.tx_bytes += skb->len;
+      netdev->trans_start   = jiffies;
+      /* --------------------------------------------------------------------------------------------------------- */
+      return NETDEV_TX_OK;
+      /* --------------------------------------------------------------------------------------------------------- */
+   }
+/* --------------------------------------------------------------------------------------------------------------- */
 #endif
-	mb();
-
-	enable_tx_dma(tx_ring_index, 1);
-
-	priv->stats.tx_packets++;
-	priv->stats.tx_bytes += skb->len;
-	netdev->trans_start = jiffies;
-
-	spin_unlock_irqrestore(&tx_lock, flags);
-
-	return NETDEV_TX_OK;
-}
 
 
 #ifdef CNS3XXX_FSQF_RING0_ISR
 irqreturn_t cns3xxx_fsqf_ring0_isr(int irq, void *dev_id)
 {
+#ifndef CONFIG_CNS3XXX_NAPI
+	struct net_device *netdev = dev_id;
+	CNS3XXXPrivate *priv = netdev_priv(netdev);
+#endif
+
 #ifdef CONFIG_CNS3XXX_NAPI
+{
 	CNS3XXXPrivate *priv = netdev_priv(napi_dev);
-
-#ifndef UDP_OVERRUN_FIXUP 
 	// because in normal state, fsql only invoke once and set_bit is atomic function.
 	// so I don't mask it.
 	set_bit(0, &priv->is_qf);
+}
 #else
-	priv->ring_index=0;
-
-	if (likely(napi_schedule_prep(&priv->napi))) {
-		__napi_schedule(&priv->napi);
-	}
-#endif
-
-#else /* ! CONFIG_CNS3XXX_NAPI */
-	struct net_device *netdev = dev_id;
-	CNS3XXXPrivate *priv = netdev_priv(netdev);
-
-	/* disable interrupt */
 #ifdef CNS3XXX_USE_MASK
 	cns3xxx_write_pri_mask(0xb0);
 #else
@@ -1490,67 +1720,22 @@
 #endif
 #endif //#if defined(CNS3XXX_DOUBLE_RX_RING)
 
-static void cns3xxx_print_link_info(struct net_device *netdev, u32 regVal)
-{
-	unsigned int link_speed = 10*((regVal>>2) & 0x3);
-
-	switch (((regVal>>2) & 0x3)){
-	case 0:
-		link_speed = 10;
-		break;
-	case 1:
-		link_speed = 100;
-		break;
-	case 2:
-		link_speed = 1000;
-		break;
-	case 3:
-	default:
-		link_speed = 0; /* Reserved */
-	}
-
-	if (regVal & 0x1)
-		printk(KERN_INFO "cns3xxx: %s NIC Link is Up %d Mbps %s, "
-		       "Flow Control: %s\n",
-		       netdev->name,
-		       link_speed,
-		       ((regVal>>4) & 0x1) ?
-		                        "Full Duplex" : "Half Duplex",
-		       ((link_speed < 1000) && ((regVal>>5) & 0x1)) ?
-		                        "RX/TX" :
-		       (((regVal>>5) & 0x1)  ? "RX" :
-		       (((regVal>>6) & 0x1)  ? "TX" : "None" )));
-	else
-		printk(KERN_INFO "cns3xxx: %s NIC Link is Down\n", netdev->name);
-}
 
 #ifdef CNS3XXX_STATUS_ISR
 irqreturn_t cns3xxx_status_isr(int irq, void *dev_id)
 {
 	u32 int_status = INTR_STAT_REG;
 	u32 i=0;
-	CNS3XXXPrivate *priv = 0;
-	NetDevicePriv *devPriv = 0;
-	struct net_device *netdev = (struct net_device *)dev_id;
-
-	/* In current design, we always get the first defined net device.
-	 */
-	priv = netdev_priv(netdev);
-	devPriv = priv->net_device_priv;
 
 	cns3xxx_disable_irq(STATUS_INTERRUPT_ID);
 	//printk("INTR_STAT_REG : %#x\n", INTR_STAT_REG);
 #ifdef CNS3XXX_SHOW_LINK_STATUS
 	for (i=14 ; i <= 16 ; ++i) {
+		//u32 cfg=0;
 		u8 mac_cfg[]={0xc, 0x10, 0x18};
 
 		if (((int_status >> i) & 1)) {
-			unsigned int devIndex = i - 14;
-
-			netdev = devPriv[devIndex].netdev;
-			//printk(KERN_INFO " cns3000: mac%d(%s): Link %s\n\r", i-14, netdev->name, (SWITCH_REG_VALUE(mac_cfg[i-14]) & 1)? "UP" :"DOWN");
-			cns3xxx_print_link_info(netdev, SWITCH_REG_VALUE(mac_cfg[i-14]));
-
+			//printk("mac %d: link %s\n", i-14, (SWITCH_REG_VALUE(mac_cfg[i-14]) & 1)? "up" :"down");
 			if ((SWITCH_REG_VALUE(mac_cfg[i-14]) & 1)){ // link up
 
       				// GMII2 high speed drive strength
@@ -1558,9 +1743,7 @@
 				if (((SWITCH_REG_VALUE(mac_cfg[i-14]) >> 2) &0x3) == 2) { // 1000 Mbps
 				        IOCDA_REG |= (2 << 10);
 				}
-				netif_carrier_on(netdev);
-			} else {
-				netif_carrier_off(netdev);
+
 			}
 
 			//printk("%x", SWITCH_REG_VALUE(mac_cfg[i-14]));
@@ -1621,34 +1804,37 @@
 		}
 #endif
 
-		if (priv->num_rx_queues == 2) {
+
+	if (priv->num_rx_queues == 2) {
 #if defined(CNS3XXX_DOUBLE_RX_RING)
-			retval = request_irq(FSRC_RING1_INTERRUPT_ID, cns3xxx_fsrc_ring1_isr, IRQF_SHARED, "FSRC_RING1", intr_netdev);
-			printk("xx intr_netdev->name: %s\n", intr_netdev->name);
+		retval = request_irq(FSRC_RING1_INTERRUPT_ID, cns3xxx_fsrc_ring1_isr, IRQF_SHARED, "FSRC_RING1", intr_netdev);
+		printk("xx intr_netdev->name: %s\n", intr_netdev->name);
 
-			if (retval) {
-				printk("%s: unable to get IRQ %d (irqval=%d).\n", "FSRC_RING1",FSRC_RING1_INTERRUPT_ID, retval);
-				return 1;
-			}
+		if (retval) {
+			printk("%s: unable to get IRQ %d (irqval=%d).\n", "FSRC_RING1",FSRC_RING1_INTERRUPT_ID, retval);
+			return 1;
+		}
 
 #ifdef CNS3XXX_FSQF_RING1_ISR
-			retval = request_irq(FSQF_RING1_INTERRUPT_ID, cns3xxx_fsqf_ring1_isr, IRQF_SHARED, "FSQF_RING1", intr_netdev);
+		retval = request_irq(FSQF_RING1_INTERRUPT_ID, cns3xxx_fsqf_ring1_isr, IRQF_SHARED, "FSQF_RING1", intr_netdev);
 
-			if (retval) {
-				PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n", "FSQF_RING1", FSQF_RING1_INTERRUPT_ID, retval);
-				return 2;
-			}
+		if (retval) {
+			PRINT_INFO("%s: unable to get IRQ %d (irqval=%d).\n", "FSQF_RING1", FSQF_RING1_INTERRUPT_ID, retval);
+			return 2;
+		}
 #endif	
 #endif
-		}
+	}
 
 #ifdef CNS3XXX_STATUS_ISR
 #ifdef CNS3XXX_SHOW_LINK_STATUS
-		INTR_MASK_REG=0xffffffff;
-		// only enable mac link status
-		INTR_MASK_REG &= (~(1 << 14));
-		INTR_MASK_REG &= (~(1 << 15));
-		INTR_MASK_REG &= (~(1 << 16));
+
+	INTR_MASK_REG=0xffffffff;
+	// only enable mac link status
+	INTR_MASK_REG &= (~(1 << 14));
+	INTR_MASK_REG &= (~(1 << 15));
+	INTR_MASK_REG &= (~(1 << 16));
+
 #endif
 		retval = request_irq(STATUS_INTERRUPT_ID, cns3xxx_status_isr, IRQF_SHARED, "GSW_STATUS", intr_netdev);
 
@@ -1660,17 +1846,20 @@
 #endif
 
 #ifdef CONFIG_CNS3XXX_NAPI
-		priv = netdev_priv(napi_dev);
-		napi_enable(&priv->napi);
-		netif_start_queue(napi_dev);
+{
+	CNS3XXXPrivate *sp = netdev_priv(napi_dev);    
+        napi_enable(&sp->napi);
+        netif_start_queue(napi_dev);
+
 #ifdef CNS3XXX_DOUBLE_RX_RING
-		priv = netdev_priv(r1_napi_dev);    
-		napi_enable(&priv->napi);
-		netif_start_queue(r1_napi_dev);
+	sp = netdev_priv(r1_napi_dev);    
+        napi_enable(&sp->napi);
+        netif_start_queue(r1_napi_dev);
 #endif
+}
 #endif
-		// enable cpu port
-		enable_port(3, 1);
+	// enable cpu port
+	enable_port(3, 1);
 
 	} // end if (install_isr_rc == 0) 
 
@@ -1685,32 +1874,37 @@
 	CNS3XXXPrivate *priv = netdev_priv(dev);
 	//static int init_state=0;
 	
-	if (cns3xxx_setup_rx_tx_res(priv) != CAVM_OK) {
+//	printk("dev->name: %s ## dev->features: %ld\n", dev->name, dev->features);
+
+//	if (cns3xxx_setup_rx_tx_res(priv) != CAVM_OK) {
+	if (cns3xxx_setup_rx_tx_res() != CAVM_OK) {
 		printk("alloc rx/tx ring fail!!\n");	
 		return -1;
 	}
 
 	netif_start_queue(dev);
+	priv->net_device_priv->open();
+	
+//	intr_netdev = dev;  //KH
+//	intr_priv   = priv; //KH
+//	device_mtu  = intr_netdev->mtu; //KH
+//	intr_pmap   = intr_priv->net_device_priv->pmap; //KH
+	
+//	printk("set MTU = %d\n",device_mtu); //KH
 
 	cns3xxx_install_isr(dev);
 
 	enable_rx_dma(0, 1);
 
-	if (priv->num_rx_queues == 2) 
-		enable_rx_dma(1, 1);
-
-#if defined(CNS3XXX_STATUS_ISR)&&defined(CNS3XXX_SHOW_LINK_STATUS)
-	/* defered the operation for mac2 until link is up
-	 * bad look but quick fix
-	 */
-	if (priv->net_device_priv != &net_device_prive[2])
-		netif_carrier_on(dev);
+//	if (priv->num_rx_queues == 2) 
+//		enable_rx_dma(1, 1);
 
-	priv->net_device_priv->open();
-#else
 	netif_carrier_on(dev);
-	priv->net_device_priv->open();
-#endif
+
+//        tx_array_index = 0;
+//        rx_array_index = 0;
+
+
 	return 0;
 }
 
@@ -1733,24 +1927,27 @@
 		free_irq(TSTC_RING0_INTERRUPT_ID, intr_netdev);
 #endif
 
-		if (priv->num_rx_queues == 2) {
-			free_irq(FSRC_RING1_INTERRUPT_ID, intr_netdev);
+	if (priv->num_rx_queues == 2) {
+		free_irq(FSRC_RING1_INTERRUPT_ID, intr_netdev);
+
 #ifdef CNS3XXX_FSQF_RING1_ISR
-			free_irq(FSQF_RING1_INTERRUPT_ID, intr_netdev);
+		free_irq(FSQF_RING1_INTERRUPT_ID, intr_netdev);
 #endif
 		}
 
 #ifdef CONFIG_CNS3XXX_NAPI
-		priv = netdev_priv(napi_dev);
+{
+	CNS3XXXPrivate *sp = netdev_priv(napi_dev);
 
-		napi_disable(&priv->napi);
-		netif_stop_queue(napi_dev);
+	napi_disable(&sp->napi);
+	netif_stop_queue(napi_dev);
 #ifdef CNS3XXX_DOUBLE_RX_RING
-		priv = netdev_priv(r1_napi_dev);
+	sp = netdev_priv(r1_napi_dev);
 
-		napi_disable(&priv->napi);
-		netif_stop_queue(r1_napi_dev);
+	napi_disable(&sp->napi);
+	netif_stop_queue(r1_napi_dev);
 #endif
+}
 #endif
 	}
 
@@ -1765,16 +1962,16 @@
 	enable_tx_dma(0, 0);
 
 	if (priv->num_rx_queues == 2) 
-		enable_rx_dma(1, 0);
+		enable_tx_dma(1, 0);
 
 	if (priv->num_tx_queues == 2) 
-		enable_tx_dma(1, 0);
+		enable_rx_dma(1, 0);
 
-	netif_stop_queue(dev);
+        netif_stop_queue(dev);
 
 	priv->net_device_priv->close();
 	cns3xxx_uninstall_isr(dev);
-	cns3xxx_free_rx_tx_res(priv);
+	//cns3xxx_free_rx_tx_res(priv);
 	netif_carrier_off(dev);
 
 	return 0;
@@ -1800,65 +1997,1725 @@
 			(unknown == 1) ? (MAC1_CFG_REG |= (1 << 28)) : (MAC1_CFG_REG &= (~(1 << 28))) ;
 			break;
 		}
-		case 2:
+		case 2:
+		{
+			(boradcast == 1) ? (MAC2_CFG_REG |= (1 << 30)) : (MAC2_CFG_REG &= (~(1 << 30))) ;
+			(multicast == 1) ? (MAC2_CFG_REG |= (1 << 29)) : (MAC2_CFG_REG &= (~(1 << 29))) ;
+			(unknown == 1) ? (MAC2_CFG_REG |= (1 << 28)) : (MAC2_CFG_REG &= (~(1 << 28))) ;
+			break;
+		}
+	}
+}
+
+void broadcast_storm_rate(u8 rate)
+{
+	TC_CTRL_REG &= (~(0xf << 24));
+	TC_CTRL_REG |= (rate << 24);
+}
+
+static int cns3xxx_set_mac_addr(struct net_device *dev, void *p)
+{
+	//struct sockaddr *sock_addr = addr;
+	CNS3XXXPrivate *priv = netdev_priv(dev);
+
+        struct sockaddr *addr= p;
+
+
+	spin_lock_irq(&priv->lock);
+
+
+        if (!is_valid_ether_addr(addr->sa_data))
+                return -EADDRNOTAVAIL;
+
+	// 1. delete old arl mac entry
+	// 2. add new arl mac entry
+	// 3. copy new mac to netdev field
+
+	if (priv->net_device_priv->arl_table_entry) {
+		cns3xxx_arl_table_invalid(priv->net_device_priv->arl_table_entry);
+		memcpy(priv->net_device_priv->arl_table_entry->mac, addr->sa_data, dev->addr_len);
+		//print_arl_table_entry(priv->net_device_priv->arl_table_entry);
+		cns3xxx_arl_table_add(priv->net_device_priv->arl_table_entry);
+	}
+        memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	spin_unlock_irq(&priv->lock);
+	return 0;
+}
+
+
+int set_fc_rls(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	FC_GLOB_THRS_REG &= (~(0x1ff << 16));
+	FC_GLOB_THRS_REG |= (ctl.val << 16);
+	return CAVM_OK;
+}
+
+int get_fc_rls(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+
+	ctl.val = ((FC_GLOB_THRS_REG >> 16) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int set_fc_set(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	FC_GLOB_THRS_REG &= (~0x1ff);
+	FC_GLOB_THRS_REG |= ctl.val;
+	return CAVM_OK;
+}
+
+int get_fc_set(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+
+	ctl.val = ((FC_GLOB_THRS_REG) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+
+int set_sarl_rls(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	SARL_CTRL_REG &= (~(0x1ff << 12));
+	SARL_CTRL_REG |= (ctl.val << 12);
+	return CAVM_OK;
+}
+
+int get_sarl_rls(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+
+	ctl.val = ((SARL_CTRL_REG >> 12) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int set_sarl_enable(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	SARL_CTRL_REG &= (~(0x1 << 31));
+	SARL_CTRL_REG |= (ctl.val << 31);
+	return CAVM_OK;
+}
+
+int get_sarl_enable(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	ctl.val = ((SARL_CTRL_REG >> 31 ) & 0x1);
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+int set_sarl_set(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	SARL_CTRL_REG &= (~0x1ff);
+	SARL_CTRL_REG |= ctl.val;
+	return CAVM_OK;
+}
+
+int get_sarl_set(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+
+	ctl.val = ((SARL_CTRL_REG) & 0x1ff);
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int set_sarl_oq(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+
+	switch (ctl.gyr)
+	{
+		case 0: // green
+		{
+			SARL_OQ_GTH_REG &= (~(0xff << ctl.tc*8));
+			SARL_OQ_GTH_REG |= (ctl.val << ctl.tc*8);
+			break;
+		}
+		case 1: // yellow
+		{
+			SARL_OQ_YTH_REG &= (~(0xff << ctl.tc*8));
+			SARL_OQ_YTH_REG |= (ctl.val << ctl.tc*8);
+			break;
+		}
+		case 2: // red
+		{
+			SARL_OQ_RTH_REG &= (~(0xff << ctl.tc*8));
+			SARL_OQ_RTH_REG |= (ctl.val << ctl.tc*8);
+			break;
+		}
+	}
+	return CAVM_OK;
+}
+
+int get_sarl_oq(struct ifreq *ifr)
+{
+	CNS3XXXSARLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+
+	switch (ctl.gyr)
+	{
+		case 0: // green
+		{
+			ctl.val = ((SARL_OQ_GTH_REG >> ctl.tc*8) & 0xff);
+			break;
+		}
+		case 1: // yellow
+		{
+			ctl.val = ((SARL_OQ_YTH_REG >> ctl.tc*8) & 0xff);
+			break;
+		}
+		case 2: // red
+		{
+			ctl.val = ((SARL_OQ_RTH_REG >> ctl.tc*8) & 0xff);
+			break;
+		}
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXSARLEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int set_queue_weight(struct ifreq *ifr)
+{
+	CNS3XXXQueueWeightEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXQueueWeightEntry)) )  
+		return -EFAULT; 
+	switch (ctl.which_port)
+	{
+		case 0:
+		{
+			QUEUE_WEIGHT_SET(0, ctl)
+			return 0;
+		}
+		case 1:
+		{
+			QUEUE_WEIGHT_SET(1, ctl)
+			return 0;
+		}
+		case 2:
+		{
+			QUEUE_WEIGHT_SET(2, ctl)
+			return 0;
+		}
+		case 3: // cpu port 
+		{
+			CPU_PRI_CTRL_REG &= ~(0x3ffff);
+			CPU_PRI_CTRL_REG |= (ctl.sch_mode << 16);
+			CPU_PRI_CTRL_REG |= (ctl.q0_w);
+			CPU_PRI_CTRL_REG |= (ctl.q1_w << 4);
+			CPU_PRI_CTRL_REG |= (ctl.q2_w << 8);
+			CPU_PRI_CTRL_REG |= (ctl.q3_w << 12);
+			return 0;
+		}
+		case 4: // PPE port 
+		{
+			HNAT_PRI_CTRL_REG &= ~(0x3ffff);
+			HNAT_PRI_CTRL_REG |= (ctl.sch_mode << 16);
+			HNAT_PRI_CTRL_REG |= (ctl.q0_w);
+			HNAT_PRI_CTRL_REG |= (ctl.q1_w << 4);
+			HNAT_PRI_CTRL_REG |= (ctl.q2_w << 8);
+			HNAT_PRI_CTRL_REG |= (ctl.q3_w << 12);
+			return 0;
+		}
+		default:
+		{
+			return -EFAULT;
+		}
+	}
+}
+
+int get_queue_weight(struct ifreq *ifr)
+{
+	CNS3XXXQueueWeightEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXQueueWeightEntry)) )  
+		return -EFAULT; 
+
+	switch (ctl.which_port)
+	{
+		case 0:
+		{
+			QUEUE_WEIGHT_GET(0, ctl)
+			break;
+		}
+		case 1:
+		{
+			QUEUE_WEIGHT_GET(1, ctl)
+			break;
+		}
+		case 2:
+		{
+			QUEUE_WEIGHT_GET(2, ctl)
+			break;
+		}
+		case 3:
+		{
+			ctl.sch_mode = ((CPU_PRI_CTRL_REG >> 16 ) & 0x3); 
+			ctl.q0_w = ((CPU_PRI_CTRL_REG >> 0 ) & 0x7); 
+			ctl.q1_w = ((CPU_PRI_CTRL_REG >> 4 ) & 0x7);
+			ctl.q2_w = ((CPU_PRI_CTRL_REG >> 8 ) & 0x7); 
+			ctl.q3_w = ((CPU_PRI_CTRL_REG >> 12 ) & 0x7); 
+			break;
+		}
+		case 4:
+		{
+			ctl.sch_mode = ((HNAT_PRI_CTRL_REG >> 16 ) & 0x3); 
+			ctl.q0_w = ((HNAT_PRI_CTRL_REG >> 0 ) & 0x7); 
+			ctl.q1_w = ((HNAT_PRI_CTRL_REG >> 4 ) & 0x7);
+			ctl.q2_w = ((HNAT_PRI_CTRL_REG >> 8 ) & 0x7); 
+			ctl.q3_w = ((HNAT_PRI_CTRL_REG >> 12 ) & 0x7); 
+			break;
+		}
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXQueueWeightEntry)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int set_rate_limit(struct ifreq *ifr)
+{
+	CNS3XXXRateLimitEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXRateLimitEntry)) )  
+		return -EFAULT; 
+	switch (ctl.which_port)
+	{
+		case 0:
+		{
+			RATE_CTRL_REG &= (~(0x7f << 8));
+			RATE_CTRL_REG |= ( ctl.band_width << 8);
+			RATE_CTRL_REG &= (~(0x3));
+			RATE_CTRL_REG |= ctl.base_rate;
+			return 0;
+		}
+		case 1:
+		{
+			RATE_CTRL_REG &= (~(0x7f << 16));
+			RATE_CTRL_REG |= ( ctl.band_width << 16);
+			RATE_CTRL_REG &= (~(0x3 << 2));
+			RATE_CTRL_REG |= (ctl.base_rate << 2);
+			return 0;
+		}
+		case 2:
+		{
+			RATE_CTRL_REG &= (~(0x7f << 24));
+			RATE_CTRL_REG |= ( ctl.band_width << 24);
+			RATE_CTRL_REG &= (~(0x3 << 4));
+			RATE_CTRL_REG |= (ctl.base_rate << 4);
+			return 0;
+		}
+		case 3: // port 0 extra dma
+		{
+			TC_CTRL_REG &= (~0x7f);
+			TC_CTRL_REG |= ctl.band_width;
+			RATE_CTRL_REG &= (~(0x3 << 6));
+			RATE_CTRL_REG |= (ctl.base_rate << 6);
+			return 0;
+		}
+		default:
+		{
+			return -EFAULT;
+		}
+	}
+}
+
+int get_rate_limit(struct ifreq *ifr)
+{
+	CNS3XXXRateLimitEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXRateLimitEntry)) )  
+		return -EFAULT; 
+	switch (ctl.which_port)
+	{
+		case 0:
+		{
+			ctl.band_width = (RATE_CTRL_REG >> 8) & 0x7f;
+			ctl.base_rate = RATE_CTRL_REG & 0x3;
+			break;
+		}
+		case 1:
+		{
+			ctl.band_width = (RATE_CTRL_REG >> 16) & 0x7f;
+			ctl.base_rate = (RATE_CTRL_REG >> 2) & 0x3;
+			break;
+		}
+		case 2:
+		{
+			ctl.band_width = (RATE_CTRL_REG >> 24) & 0x7f;
+			ctl.base_rate = (RATE_CTRL_REG >> 4) & 0x3;
+			break;
+		}
+		case 3: // port 0 extra dma
+		{
+			ctl.band_width = (TC_CTRL_REG) & 0x7f;
+			ctl.base_rate = (RATE_CTRL_REG >> 6) & 0x3;
+			break;
+		}
+		default:
+		{
+			return -EFAULT;
+		}
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXRateLimitEntry)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int set_fc(struct ifreq *ifr)
+{
+	CNS3XXXFCEntry ctl;
+	u32 port_offset[]={0x0c, 0x10, 0x18, 0x14}; // 0x14 is cpu port offset
+	u32 val=0;
+
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXFCEntry)) )  
+		return -EFAULT; 
+
+	val = SWITCH_REG_VALUE(port_offset[ctl.port]);
+	if (ctl.port == 3) { // cpu port, only can set rx fc
+		val &= (~(1 << 31));
+		if (ctl.fc_en) 
+			val |= (1 << 31);
+	} else {
+		val &= (~(1 << 11)); // disable rx fc
+		val &= (~(1 << 12)); // disable tx fc
+		val |= (ctl.fc_en << 11);
+	}
+
+	SWITCH_REG_VALUE(port_offset[ctl.port]) = val;
+	return CAVM_OK;
+}
+
+int get_fc(struct ifreq *ifr)
+{
+	CNS3XXXFCEntry ctl;
+	u32 port_offset[]={0x0c, 0x10, 0x18, 0x14}; // 0x14 is cpu port offset
+	u32 val=0;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXFCEntry)) )  
+		return -EFAULT; 
+
+	val = SWITCH_REG_VALUE(port_offset[ctl.port]);
+	printk("port_offset[%d]: %x\n", ctl.port, port_offset[ctl.port]);
+	printk("val: %x\n", val);
+	if (ctl.port == 3) { // cpu port, only can set rx fc
+		ctl.fc_en = ((val >> 31) & 1);
+	} else {
+		ctl.fc_en = ((val >> 11) & 3);
+
+	}
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXFCEntry)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int set_ivl(struct ifreq *ifr)
+{
+	CNS3XXXIVLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXIVLEntry)) )  
+		return -EFAULT; 
+
+	cns3xxx_ivl(ctl.enable);
+
+	return CAVM_OK;
+}
+
+int get_ivl(struct ifreq *ifr)
+{
+	CNS3XXXIVLEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXIVLEntry)) )  
+		return -EFAULT; 
+
+	ctl.enable = ((MAC_GLOB_CFG_REG >> 7) & 0x1);
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXIVLEntry)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int set_wan_port(struct ifreq *ifr)
+{
+	CNS3XXXWANPortEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXWANPortEntry)) )  
+		return -EFAULT; 
+	VLAN_CFG &= (~(0x1f << 8));
+	VLAN_CFG |= (ctl.wan_port << 8);
+
+	return CAVM_OK;
+}
+int get_wan_port(struct ifreq *ifr)
+{
+	CNS3XXXWANPortEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXWANPortEntry)) )  
+		return -EFAULT; 
+
+	ctl.wan_port = ((VLAN_CFG >> 8) & 0x1f);
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXWANPortEntry)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int set_pvid(struct ifreq *ifr)
+{
+	CNS3XXXPVIDEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXPVIDEntry)) )  
+		return -EFAULT; 
+	cns3xxx_set_pvid(ctl.which_port, ctl.pvid);
+
+	return CAVM_OK;
+}
+
+int get_pvid(struct ifreq *ifr)
+{
+	CNS3XXXPVIDEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXPVIDEntry)) )  
+		return -EFAULT; 
+
+	ctl.pvid = cns3xxx_get_pvid(ctl.which_port);
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXPVIDEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int set_qa(struct ifreq *ifr)
+{
+	CNS3XXXQAEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXQAEntry)) )  
+		return -EFAULT; 
+
+	MAC_GLOB_CFG_EXT_REG &= ~(0x7 << 27);
+	MAC_GLOB_CFG_EXT_REG |= (ctl.qa << 27);
+	//printk("[kernel mode] ctl.qa: %d\n", ctl.qa);
+	
+	return CAVM_OK;
+}
+
+int get_qa(struct ifreq *ifr)
+{
+	CNS3XXXQAEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXQAEntry)) )  
+		return -EFAULT; 
+
+	ctl.qa = (MAC_GLOB_CFG_EXT_REG >> 27) & 0x7;
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXQAEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int get_packet_max_len(struct ifreq *ifr)
+{
+	CNS3XXXMaxLenEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXMaxLenEntry)) )  
+		return -EFAULT; 
+
+	ctl.max_len = (PHY_AUTO_ADDR_REG >> 30) & 0x3;
+
+	if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXMaxLenEntry)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+int set_packet_max_len(struct ifreq *ifr)
+{
+	CNS3XXXMaxLenEntry ctl;
+
+	if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXMaxLenEntry)) )  
+		return -EFAULT; 
+
+	PHY_AUTO_ADDR_REG &= (~(3 << 30));
+	PHY_AUTO_ADDR_REG |= (ctl.max_len << 30);
+
+	return CAVM_OK;
+}
+
+int set_udp_range(struct ifreq *ifr)
+{
+	CNS3XXXUdpRangeEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXUdpRangeEtypeControl)) )  
+		return -EFAULT; 
+
+	switch (conf.udp_range_num)
+	{
+		case 0:
+		{
+			UDP_RANGE0_REG = 0;
+			UDP_RANGE0_REG |= conf.port_start;
+			UDP_RANGE0_REG |= (conf.port_end << 16);
+			break;
+		}
+		case 1:
+		{
+			UDP_RANGE1_REG = 0;
+			UDP_RANGE1_REG |= conf.port_start;
+			UDP_RANGE1_REG |= (conf.port_end << 16);
+			break;
+		}
+		case 2:
+		{
+			UDP_RANGE2_REG = 0;
+			UDP_RANGE2_REG |= conf.port_start;
+			UDP_RANGE2_REG |= (conf.port_end << 16);
+			break;
+		}
+		case 3:
+		{
+			UDP_RANGE3_REG = 0;
+			UDP_RANGE3_REG |= conf.port_start;
+			UDP_RANGE3_REG |= (conf.port_end << 16);
+			break;
+		}
+	}
+
+	return CAVM_OK;
+}
+
+int get_udp_range(struct ifreq *ifr)
+{
+	CNS3XXXUdpRangeEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXUdpRangeEtypeControl)) )  
+		return -EFAULT; 
+
+	switch (conf.udp_range_num)
+	{
+		case 0:
+		{
+			conf.port_start = (UDP_RANGE0_REG & 0xffff);
+			conf.port_end = ((UDP_RANGE0_REG >> 16 )& 0xffff);
+			break;
+		}
+		case 1:
+		{
+			conf.port_start = (UDP_RANGE1_REG & 0xffff);
+			conf.port_end = ((UDP_RANGE1_REG >> 16 )& 0xffff);
+			break;
+		}
+		case 2:
+		{
+			conf.port_start = (UDP_RANGE2_REG & 0xffff);
+			conf.port_end = ((UDP_RANGE2_REG >> 16 )& 0xffff);
+			break;
+		}
+		case 3:
+		{
+			conf.port_start = (UDP_RANGE3_REG & 0xffff);
+			conf.port_end = ((UDP_RANGE3_REG >> 16 )& 0xffff);
+			break;
+		}
+	}
+
+	if (copy_to_user(ifr->ifr_data, &conf, sizeof(CNS3XXXUdpRangeEtypeControl)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int get_etype(struct ifreq *ifr)
+{
+	CNS3XXXEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXEtypeControl)) )  
+		return -EFAULT; 
+	switch (conf.etype_num)
+	{
+		case 0:
+		{
+			conf.val = (ETYPE1_ETYPE0_REG & 0xffff);
+			conf.pri = (PRIO_ETYPE_UDP_REG & 0x7);
+			break;
+		}
+		case 1:
+		{
+			conf.val = ((ETYPE1_ETYPE0_REG >> 16 )& 0xffff);
+			conf.pri = ((PRIO_ETYPE_UDP_REG >> 4) & 0x7);
+			break;
+		}
+		case 2:
+		{
+			conf.val = (ETYPE3_ETYPE2_REG & 0xffff);
+			conf.pri = ((PRIO_ETYPE_UDP_REG >> 8) & 0x7);
+			break;
+		}
+		case 3:
+		{
+			conf.val = ((ETYPE3_ETYPE2_REG >> 16 )& 0xffff);
+			conf.pri = ((PRIO_ETYPE_UDP_REG >> 12) & 0x7);
+			break;
+		}
+	}
+	if (copy_to_user(ifr->ifr_data, &conf, sizeof(CNS3XXXEtypeControl)) )  
+		return -EFAULT; 
+
+	return CAVM_OK;
+}
+
+int set_etype(struct ifreq *ifr)
+{
+	CNS3XXXEtypeControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXEtypeControl)) )  
+		return -EFAULT; 
+	switch (conf.etype_num)
+	{
+		case 0:
+		{
+			ETYPE1_ETYPE0_REG &= (~0xffff);
+			ETYPE1_ETYPE0_REG |= conf.val;
+
+			PRIO_ETYPE_UDP_REG &= (~7);
+			PRIO_ETYPE_UDP_REG |= (conf.pri);
+			break;
+		}
+		case 1:
+		{
+			ETYPE1_ETYPE0_REG &= (~(0xffff << 16));
+			ETYPE1_ETYPE0_REG |= (conf.val << 16);
+
+			PRIO_ETYPE_UDP_REG &= (~(7 << 4));
+			PRIO_ETYPE_UDP_REG |= (conf.pri << 4);
+			break;
+		}
+		case 2:
+		{
+			ETYPE3_ETYPE2_REG &= (~0xffff);
+			ETYPE3_ETYPE2_REG |= conf.val;
+
+			PRIO_ETYPE_UDP_REG &= (~(7 << 8));
+			PRIO_ETYPE_UDP_REG |= (conf.pri << 8);
+			break;
+		}
+		case 3:
+		{
+			ETYPE3_ETYPE2_REG &= (~(0xffff << 16));
+			ETYPE3_ETYPE2_REG |= (conf.val << 16);
+
+			PRIO_ETYPE_UDP_REG &= (~(7 << 12));
+			PRIO_ETYPE_UDP_REG |= (conf.pri << 12);
+			break;
+		}
+	}
+	return CAVM_OK;
+}
+
+int get_pri_ip_dscp(struct ifreq *ifr)
+{
+	CNS3XXXPriIpDscpControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXPriIpDscpControl)) )  
+		return -EFAULT; 
+
+	if ( 0 <= conf.ip_dscp_num && conf.ip_dscp_num <= 7) {
+		conf.pri = ((PRIO_IPDSCP_7_0_REG >> (conf.ip_dscp_num * 4)) & 0x7);
+	} else if ( 8 <= conf.ip_dscp_num && conf.ip_dscp_num <= 15) {
+			conf.pri = ((PRIO_IPDSCP_15_8_REG >> ((conf.ip_dscp_num-8) * 4)) & 0x7);
+		 } else if ( 16 <= conf.ip_dscp_num && conf.ip_dscp_num <= 23) {
+				conf.pri = ((PRIO_IPDSCP_23_16_REG >> ((conf.ip_dscp_num-16) * 4)) & 0x7);
+		 	} else if ( 24 <= conf.ip_dscp_num && conf.ip_dscp_num <= 31) {
+					conf.pri = ((PRIO_IPDSCP_31_24_REG >> ((conf.ip_dscp_num-24) * 4)) & 0x7);
+		 		} else if ( 32 <= conf.ip_dscp_num && conf.ip_dscp_num <= 39) {
+						conf.pri = ((PRIO_IPDSCP_39_32_REG >> ((conf.ip_dscp_num-32) * 4)) & 0x7);
+		 			} else if ( 40 <= conf.ip_dscp_num && conf.ip_dscp_num <= 47) {
+							conf.pri = ((PRIO_IPDSCP_47_40_REG >> ((conf.ip_dscp_num-40) * 4)) & 0x7);
+		 				} else if ( 48 <= conf.ip_dscp_num && conf.ip_dscp_num <= 55) {
+								conf.pri = ((PRIO_IPDSCP_55_48_REG >> ((conf.ip_dscp_num-48) * 4)) & 0x7);
+		 					} else if ( 56 <= conf.ip_dscp_num && conf.ip_dscp_num <= 63) {
+									conf.pri = ((PRIO_IPDSCP_63_56_REG >> ((conf.ip_dscp_num-56) * 4)) & 0x7);
+								} else {
+									return CAVM_ERR;
+									}
+
+
+	if (copy_to_user(ifr->ifr_data, &conf, sizeof(CNS3XXXPriIpDscpControl)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+
+int set_pri_ip_dscp(struct ifreq *ifr)
+{
+	CNS3XXXPriIpDscpControl conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXPriIpDscpControl)) )  
+		return -EFAULT; 
+
+	if ( 0 <= conf.ip_dscp_num && conf.ip_dscp_num <= 7) {
+		PRIO_IPDSCP_7_0_REG &=  (~(0x7 << (conf.ip_dscp_num * 4) ) );
+		PRIO_IPDSCP_7_0_REG |= (conf.pri << (conf.ip_dscp_num * 4));
+	} else if ( 8 <= conf.ip_dscp_num && conf.ip_dscp_num <= 15) {
+			PRIO_IPDSCP_15_8_REG &=  (~(0x7 << ((conf.ip_dscp_num-8) * 4) ) );
+			PRIO_IPDSCP_15_8_REG |= (conf.pri << ((conf.ip_dscp_num-8) * 4));
+		 } else if ( 16 <= conf.ip_dscp_num && conf.ip_dscp_num <= 23) {
+				PRIO_IPDSCP_23_16_REG &=  (~(0x7 << ((conf.ip_dscp_num-16) * 4) ) );
+				PRIO_IPDSCP_23_16_REG |= (conf.pri << ((conf.ip_dscp_num-16) * 4));
+
+		 	} else if ( 24 <= conf.ip_dscp_num && conf.ip_dscp_num <= 31) {
+					PRIO_IPDSCP_31_24_REG &=  (~(0x7 << ((conf.ip_dscp_num-24) * 4) ) );
+					PRIO_IPDSCP_31_24_REG |= (conf.pri << ((conf.ip_dscp_num-24) * 4));
+
+		 		} else if ( 32 <= conf.ip_dscp_num && conf.ip_dscp_num <= 39) {
+						PRIO_IPDSCP_39_32_REG &=  (~(0x7 << ((conf.ip_dscp_num-32) * 4) ) );
+						PRIO_IPDSCP_39_32_REG |= (conf.pri << ((conf.ip_dscp_num-32) * 4));
+
+		 			} else if ( 40 <= conf.ip_dscp_num && conf.ip_dscp_num <= 47) {
+							PRIO_IPDSCP_47_40_REG &=  (~(0x7 << ((conf.ip_dscp_num-40) * 4) ) );
+							PRIO_IPDSCP_47_40_REG |= (conf.pri << ((conf.ip_dscp_num-40) * 4));
+		 				} else if ( 48 <= conf.ip_dscp_num && conf.ip_dscp_num <= 55) {
+								PRIO_IPDSCP_55_48_REG &=  (~(0x7 << ((conf.ip_dscp_num-48) * 4) ) );
+								PRIO_IPDSCP_55_48_REG |= (conf.pri << ((conf.ip_dscp_num-48) * 4));
+		 					} else if ( 56 <= conf.ip_dscp_num && conf.ip_dscp_num <= 63) {
+									PRIO_IPDSCP_63_56_REG &=  (~(0x7 << ((conf.ip_dscp_num-56) * 4) ) );
+									PRIO_IPDSCP_63_56_REG |= (conf.pri << ((conf.ip_dscp_num-56) * 4));
+								} else {
+									return CAVM_ERR;
+									}
+	return CAVM_OK;
+}
+
+
+#if (defined(CONFIG_VB) || defined (CONFIG_VB_2))
+
+extern int bcm53115M_reg_read(int page, int offset, u8 *buf, int len);
+
+int bcm53115M_reg_read_ioctl(struct ifreq *ifr)
+{
+	CNS3XXXBCM53115M conf;
+	int __init_or_module gpio_direction_output(unsigned int pin, unsigned int state);
+
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXBCM53115M)) )  
+		return -EFAULT; 
+	printk("conf.page: %x\n", conf.page);
+	printk("conf.offset: %x\n", conf.offset);
+	printk("conf.data_len: %x\n", conf.data_len);
+	switch (conf.data_len)
+	{
+		case 1:
+		{
+			bcm53115M_reg_read(conf.page, conf.offset, (u8 *)&conf.u8_val, 1);
+			printk("conf.u8_val: %x\n", conf.u8_val);
+			break;
+		}
+		case 2:
+		{
+			bcm53115M_reg_read(conf.page, conf.offset, (u8 *)&conf.u16_val, 2);
+			printk("conf.u16_val: %x\n", conf.u16_val);
+			break;
+		}
+		case 4:
+		{
+			bcm53115M_reg_read(conf.page, conf.offset, (u8 *)&conf.u32_val, 4);
+			printk("conf.u32_val: %x\n", conf.u32_val);
+			break;
+		}
+		default:
+		{
+			printk("[kernel mode]: don't support date length: %d\n", conf.data_len);
+		}
+	}
+
+
+
+	if (copy_to_user(ifr->ifr_data, &conf, sizeof(CNS3XXXBCM53115M)) )  
+		return -EFAULT; 
+	return CAVM_OK;
+}
+
+extern int bcm53115M_reg_write(int page, int offset, u8 *buf, int len);
+
+int bcm53115M_reg_write_ioctl(struct ifreq *ifr)
+{
+	CNS3XXXBCM53115M conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXBCM53115M)) )  
+		return -EFAULT; 
+
+	switch (conf.data_len)
+	{
+		case 1:
+		{
+        		bcm53115M_reg_write(conf.page, conf.offset, (u8 *)&conf.u8_val, 1);
+			break;
+		}
+		case 2:
+		{
+			bcm53115M_reg_write(conf.page, conf.offset, (u8 *)&conf.u16_val, 2);
+			break;
+		}
+		case 4:
+		{
+			bcm53115M_reg_write(conf.page, conf.offset, (u8 *)&conf.u32_val, 4);
+			break;
+		}
+		default:
+		{
+			printk("[kernel mode]: don't support date length: %d\n", conf.data_len);
+		}
+	}
+	return CAVM_OK;
+}
+#endif
+
+#if 0
+int get_rxring(struct ifreq *ifr)
+{
+	CNS3XXXRingStatus conf;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXRingStatus)) )  
+		return -EFAULT; 
+	conf.rx_ring=g_ring_info.rx_ring;
+	conf.tx_ring=0;
+	if (copy_to_user(ifr->ifr_data, &conf, sizeof(CNS3XXXRingStatus)) )  
+		return -EFAULT; 
+}
+#endif
+
+int dump_mib_counter(struct ifreq *ifr)
+{
+	CNS3XXXMIBCounter conf;
+	int addr=0,i=0;
+
+	if (copy_from_user(&conf, ifr->ifr_data, sizeof(CNS3XXXMIBCounter)) )  
+		return -EFAULT; 
+
+	for (addr=0x300; addr <= 0x334 ; addr+=4)
+		conf.mib[i++]=SWITCH_REG_VALUE(addr);
+	for (addr=0x400; addr <= 0x434 ; addr+=4)
+		conf.mib[i++]=SWITCH_REG_VALUE(addr);
+	for (addr=0x600; addr <= 0x634 ; addr+=4)
+		conf.mib[i++]=SWITCH_REG_VALUE(addr);
+	// cpu mib counter
+	for (addr=0x500; addr <= 0x528 ; addr+=4)
+		conf.mib[i++]=SWITCH_REG_VALUE(addr);
+	conf.mib_len=i;
+	if (copy_to_user(ifr->ifr_data, &conf, sizeof(CNS3XXXMIBCounter)) )  
+		return -EFAULT; 
+	return 0;
+}
+
+// reference e100.c
+int cns3xxx_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	CNS3XXXIoctlCmd ioctl_cmd;
+
+	//printk("cns3xxx_do_ioctl begin\n");
+
+        if (cmd != SIOCDEVPRIVATE) {
+                return -EOPNOTSUPP;
+        }
+        if (copy_from_user(&ioctl_cmd, ifr->ifr_data, sizeof(CNS3XXXIoctlCmd))) 
+                return -EFAULT;
+
+	//printk("ioctl_cmd: %d\n", ioctl_cmd);
+	switch (ioctl_cmd) {
+		case CNS3XXX_ARP_REQUEST_SET:
+		{
+			CNS3XXXArpRequestControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXArpRequestControl)) ) 
+				return -EFAULT;
+
+			(ctl.val==0) ? (MAC_GLOB_CFG_REG &= (~(1 << 23)) ): (MAC_GLOB_CFG_REG |= (1 << 23) );
+
+		}
+
+		case CNS3XXX_ARP_REQUEST_GET:
+		{
+			CNS3XXXArpRequestControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXArpRequestControl)) ) 
+				return -EFAULT;
+
+			ctl.val = ((MAC_GLOB_CFG_REG >> 23) & 1);
+
+			if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXArpRequestControl)) )  
+				return -EFAULT; 
+			return CAVM_OK;
+		}
+	
+		case CNS3XXX_HOL_PREVENT_SET:
+		{
+			CNS3XXXHOLPreventControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXHOLPreventControl)) ) 
+				return -EFAULT;
+			(ctl.enable == 1) ? (TC_CTRL_REG |= (1 << 29)) : (TC_CTRL_REG &= (~(1 << 29))) ;
+
+			return CAVM_OK;
+		}
+		case CNS3XXX_HOL_PREVENT_GET:
+		{
+			CNS3XXXHOLPreventControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXHOLPreventControl)) ) 
+				return -EFAULT;
+
+			ctl.enable = ((TC_CTRL_REG >> 29) & 0x1);
+
+			if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXHOLPreventControl)) )  
+				return -EFAULT; 
+			return CAVM_OK;
+		}
+
+		// for S component or C conponent
+		case CNS3XXX_BRIDGE_SET:
+		{
+			CNS3XXXBridgeControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXBridgeControl)) ) 
+				return -EFAULT;
+			(ctl.type == 1) ? (VLAN_CFG |= (1 << 1)) : (VLAN_CFG &= (~(1 << 1))) ;
+
+
+		}
+		case CNS3XXX_BRIDGE_GET:
+		{
+			CNS3XXXBridgeControl ctl;
+
+			ctl.type = ((VLAN_CFG >> 1) & 0x1);
+			printk("[kernel mode] ctl.type: %d\n", ctl.type);
+
+			if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXBridgeControl)) )  
+				return -EFAULT; 
+
+			return CAVM_OK;
+		}
+
+		case CNS3XXX_PORT_NEIGHBOR_SET:
+		{
+			CNS3XXXPortNeighborControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXPortNeighborControl)) ) 
+				return -EFAULT;
+			switch (ctl.which_port)
+			{
+				case 0:
+				{
+					(ctl.type == 1) ? (VLAN_CFG |= (1 << 4)) : (VLAN_CFG &= (~(1 << 4))) ;
+					return 0;
+				}
+				case 1:
+				{
+					(ctl.type == 1) ? (VLAN_CFG |= (1 << 5)) : (VLAN_CFG &= (~(1 << 5))) ;
+					return 0;
+				}
+				case 2:
+				{
+					(ctl.type == 1) ? (VLAN_CFG |= (1 << 7)) : (VLAN_CFG &= (~(1 << 7))) ;
+					return 0;
+				}
+				case 3: // cpu port
+				{
+					(ctl.type == 1) ? (VLAN_CFG |= (1 << 6)) : (VLAN_CFG &= (~(1 << 6))) ;
+					return 0;
+				}
+				default:
+					return -EFAULT;
+			}
+
+		}
+
+		case CNS3XXX_PORT_NEIGHBOR_GET:
+		{
+			CNS3XXXPortNeighborControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXPortNeighborControl)) ) 
+				return -EFAULT;
+			switch (ctl.which_port)
+			{
+				case 0:
+				{
+					ctl.type = ((VLAN_CFG >> 4 ) & 0x1);
+					break;
+				}
+				case 1:
+				{
+					ctl.type = ((VLAN_CFG >> 5 ) & 0x1);
+					break;
+				}
+				case 2:
+				{
+					ctl.type = ((VLAN_CFG >> 7 ) & 0x1);
+					break;
+				}
+				case 3: // cpu port
+				{
+					ctl.type = ((VLAN_CFG >> 6 ) & 0x1);
+					break;
+				}
+			}
+
+			if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXPortNeighborControl)) )  
+				return -EFAULT; 
+
+			return CAVM_OK;
+		}
+
+		case CNS3XXX_VLAN_TABLE_LOOKUP:
+		{
+			CNS3XXXVLANTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXVLANTableEntry)) ) 
+				return -EFAULT;
+			if (cns3xxx_vlan_table_lookup(&ctl.entry) ==  CAVM_NOT_FOUND) {
+				return CAVM_NOT_FOUND;
+			}
+
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXVLANTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_FOUND;
+		}
+		case CNS3XXX_VLAN_TABLE_READ:
+		{
+			CNS3XXXVLANTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXVLANTableEntry)) ) 
+			{
+				return -EFAULT;
+			}
+			cns3xxx_vlan_table_read(&ctl.entry);
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXVLANTableEntry)))
+		                return -EFAULT;
+
+			return 0;
+		}
+		case CNS3XXX_VLAN_TABLE_ADD:
+		{	
+			CNS3XXXVLANTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXVLANTableEntry)) ) 
+				return -EFAULT;
+			cns3xxx_vlan_table_add(&ctl.entry);
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXVLANTableEntry)))
+		                return -EFAULT;
+
+			return 0;
+		}
+
+		case CNS3XXX_ARL_TABLE_ADD:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+			printk("[kernel mode] CNS3XXX_ARL_TABLE_ADD\n");
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			cns3xxx_arl_table_add(&ctl.entry);
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return 0;
+		}
+
+
+		case CNS3XXX_ARL_TABLE_DEL:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			cns3xxx_arl_table_invalid(&ctl.entry);
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return 0;
+		}
+		case CNS3XXX_VLAN_TABLE_DEL:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			cns3xxx_arl_table_invalid(&ctl.entry);
+
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_FOUND;
+		}
+
+		case CNS3XXX_ARL_TABLE_SEARCH:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			if (cns3xxx_arl_table_search(&ctl.entry) == CAVM_NOT_FOUND){
+				printk("[kernel mode] not found\n");
+				return CAVM_NOT_FOUND;
+			}
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_FOUND;
+		}
+		case CNS3XXX_ARL_IS_TABLE_END:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			if (cns3xxx_is_arl_table_end() == CAVM_ERR)
+				return CAVM_ERR;
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_OK;
+		}
+
+		case CNS3XXX_ARL_TABLE_SEARCH_AGAIN:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			if (cns3xxx_arl_table_search_again(&ctl.entry) == CAVM_NOT_FOUND)
+				return CAVM_NOT_FOUND;
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_FOUND;
+		}
+
+		case CNS3XXX_ARL_TABLE_FLUSH:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+
+			cns3xxx_arl_table_flush();
+
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_FOUND;
+		}
+
+
+
+		case CNS3XXX_ARL_TABLE_LOOKUP:
+		{	
+			CNS3XXXARLTableEntry ctl;
+
+		
+			printk("[kernel mode] in CNS3XXX_ARL_TABLE_LOOKUP\n");
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXARLTableEntry)) ) 
+				return -EFAULT;
+			if (cns3xxx_arl_table_lookup(&ctl.entry) == CAVM_NOT_FOUND)
+				return CAVM_NOT_FOUND;
+		        if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXARLTableEntry)))
+		                return -EFAULT;
+
+			return CAVM_FOUND;
+		}
+
+		case CNS3XXX_TC_SET:
+		{	
+			CNS3XXXTrafficClassControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXTrafficClassControl)) ) 
+				return -EFAULT;
+			TC_CTRL_REG &= (~(0x3 << 30));
+			TC_CTRL_REG |= (ctl.tc << 30);
+			return CAVM_OK;
+		}
+		case CNS3XXX_TC_GET:
+		{
+			CNS3XXXTrafficClassControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXTrafficClassControl)) ) 
+				return -EFAULT;
+
+			ctl.tc = ((TC_CTRL_REG >> 30) & 0x3);
+
+			if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXTrafficClassControl)) )  
+				return -EFAULT; 
+
+			return CAVM_OK;
+		}
+
+		case CNS3XXX_PRI_CTRL_SET:
+		{
+			CNS3XXXPriCtrlControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXPriCtrlControl)) ) 
+				return -EFAULT;
+
+			switch (ctl.which_port)
+			{
+				case 0:
+				{
+					MAC0_PRI_CTRL_REG &= (~(0x7 << 24));
+					MAC0_PRI_CTRL_REG &= (~(0xf << 18));
+					
+					MAC0_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+					MAC0_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+					MAC0_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+					MAC0_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+					MAC0_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+					break;
+				}
+				case 1:
+				{
+					MAC1_PRI_CTRL_REG &= (~(0x7 << 24));
+					MAC1_PRI_CTRL_REG &= (~(0xf << 18));
+					
+					MAC1_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+					MAC1_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+					MAC1_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+					MAC1_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+					MAC1_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+					break;
+				}
+				case 2:
+				{
+					MAC2_PRI_CTRL_REG &= (~(0x7 << 24));
+					MAC2_PRI_CTRL_REG &= (~(0xf << 18));
+					
+					MAC2_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+					MAC2_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+					MAC2_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+					MAC2_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+					MAC2_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+					break;
+				}
+				case 3: // cpu
+				{
+					printk("[kernel mode] CPU_PRI_CTRL_REG: %#x\n", CPU_PRI_CTRL_REG);
+					CPU_PRI_CTRL_REG &= (~(0x7 << 24));
+					CPU_PRI_CTRL_REG &= (~(0xf << 18));
+					
+					CPU_PRI_CTRL_REG |= (ctl.port_pri << 24);
+
+					CPU_PRI_CTRL_REG |= (ctl.ether_pri_en << 18);
+					CPU_PRI_CTRL_REG |= (ctl.vlan_pri_en << 19);
+					CPU_PRI_CTRL_REG |= (ctl.dscp_pri_en << 20);
+					CPU_PRI_CTRL_REG |= (ctl.udp_pri_en << 21);
+					break;
+				}
+			}
+
+			return CAVM_OK;
+		}
+
+		case CNS3XXX_PRI_CTRL_GET:
+		{
+			CNS3XXXPriCtrlControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXPriCtrlControl)) ) 
+				return -EFAULT;
+
+
+			if (copy_to_user(ifr->ifr_data, &ctl, sizeof(CNS3XXXPriCtrlControl)) )  
+				return -EFAULT; 
+
+			return CAVM_OK;
+		}
+
+		case CNS3XXX_DMA_RING_CTRL_SET:
+		{
+			CNS3XXXDmaRingCtrlControl ctl;
+
+		        if (copy_from_user(&ctl, ifr->ifr_data, sizeof(CNS3XXXDmaRingCtrlControl)) ) 
+				return -EFAULT;
+
+			(ctl.ts_double_ring_en == 0) ? DMA_RING_CTRL_REG &= (~(0x1 << 16)) : (DMA_RING_CTRL_REG |= (ctl.ts_double_ring_en << 16));
+			(ctl.fs_double_ring_en == 0) ? DMA_RING_CTRL_REG &= (~(0x1 << 0)) : (DMA_RING_CTRL_REG |= (ctl.fs_double_ring_en << 0));
+			(ctl.fs_pkt_allocate == 0) ? DMA_RING_CTRL_REG &= (~(0x1 << 1)) : (DMA_RING_CTRL_REG |= (ctl.fs_pkt_allocate << 1));
+		}
+
+		case CNS3XXX_PRI_IP_DSCP_SET:
+		{
+			return set_pri_ip_dscp(ifr);
+		}
+		case CNS3XXX_PRI_IP_DSCP_GET:
+		{
+			return get_pri_ip_dscp(ifr);
+		}
+
+		case CNS3XXX_ETYPE_SET:
+		{
+			return set_etype(ifr);
+		}
+		case CNS3XXX_ETYPE_GET:
+		{
+			return get_etype(ifr);
+		}
+
+		case CNS3XXX_UDP_RANGE_SET:
+		{
+			return set_udp_range(ifr);
+		}
+		case CNS3XXX_UDP_RANGE_GET:
+		{
+			return get_udp_range(ifr);
+		}
+
+		case CNS3XXX_RATE_LIMIT_SET:
+		{
+			return set_rate_limit(ifr);
+		}
+		case CNS3XXX_RATE_LIMIT_GET:
+		{
+			return get_rate_limit(ifr);
+		}
+		case CNS3XXX_QUEUE_WEIGHT_SET:
+		{
+			return set_queue_weight(ifr);
+		}
+		case CNS3XXX_QUEUE_WEIGHT_GET:
+		{
+			return get_queue_weight(ifr);
+		}
+
+		case CNS3XXX_FC_RLS_SET:
+		{
+			return set_fc_rls(ifr);
+		}
+		case CNS3XXX_FC_RLS_GET:
+		{
+			return get_fc_rls(ifr);
+		}
+
+		case CNS3XXX_FC_SET_SET:
+		{
+			return set_fc_set(ifr);
+		}
+		case CNS3XXX_FC_SET_GET:
+		{
+			return get_fc_set(ifr);
+		}
+
+		case CNS3XXX_SARL_RLS_SET:
+		{
+			return set_sarl_rls(ifr);
+		}
+		case CNS3XXX_SARL_RLS_GET:
+		{
+			return get_sarl_rls(ifr);
+		}
+
+		case CNS3XXX_SARL_SET_SET:
+		{
+			return set_sarl_set(ifr);
+		}
+		case CNS3XXX_SARL_SET_GET:
+		{
+			return get_sarl_set(ifr);
+		}
+
+		case CNS3XXX_SARL_OQ_SET:
+		{
+			return set_sarl_oq(ifr);
+		}
+		case CNS3XXX_SARL_OQ_GET:
+		{
+			return get_sarl_oq(ifr);
+		}
+
+		case CNS3XXX_SARL_ENABLE_SET:
+		{
+			return set_sarl_enable(ifr);
+		}
+		case CNS3XXX_SARL_ENABLE_GET:
+		{
+			return get_sarl_enable(ifr);
+		}
+
+		case CNS3XXX_FC_SET:
+		{
+			return set_fc(ifr);
+		}
+		case CNS3XXX_FC_GET:
 		{
-			(boradcast == 1) ? (MAC2_CFG_REG |= (1 << 30)) : (MAC2_CFG_REG &= (~(1 << 30))) ;
-			(multicast == 1) ? (MAC2_CFG_REG |= (1 << 29)) : (MAC2_CFG_REG &= (~(1 << 29))) ;
-			(unknown == 1) ? (MAC2_CFG_REG |= (1 << 28)) : (MAC2_CFG_REG &= (~(1 << 28))) ;
-			break;
+			return get_fc(ifr);
 		}
-	}
-}
-
-void broadcast_storm_rate(u8 rate)
-{
-	TC_CTRL_REG &= (~(0xf << 24));
-	TC_CTRL_REG |= (rate << 24);
-}
 
-static int cns3xxx_set_mac_addr(struct net_device *dev, void *p)
-{
-	//struct sockaddr *sock_addr = addr;
-	CNS3XXXPrivate *priv = netdev_priv(dev);
+		case CNS3XXX_IVL_SET:
+		{
+			return set_ivl(ifr);
+		}
+		case CNS3XXX_IVL_GET:
+		{
+			return get_ivl(ifr);
+		}
 
-        struct sockaddr *addr= p;
+		case CNS3XXX_WAN_PORT_SET:
+		{
+			return set_wan_port(ifr);
+		}
+		case CNS3XXX_WAN_PORT_GET:
+		{
+			return get_wan_port(ifr);
+		}
 
+		case CNS3XXX_PVID_SET:
+		{
+			return set_pvid(ifr);
+		}
+		case CNS3XXX_PVID_GET:
+		{
+			return get_pvid(ifr);
+		}
 
-	spin_lock_irq(&priv->lock);
+		case CNS3XXX_QA_GET:
+		{
+			return get_qa(ifr);
+		}
+		case CNS3XXX_QA_SET:
+		{
+			return set_qa(ifr);
+		}
 
+		case CNS3XXX_PACKET_MAX_LEN_GET:
+		{
+			return get_packet_max_len(ifr);
+		}
+		case CNS3XXX_PACKET_MAX_LEN_SET:
+		{
+			return set_packet_max_len(ifr);
+		}
 
-        if (!is_valid_ether_addr(addr->sa_data))
-                return -EADDRNOTAVAIL;
+#if (defined(CONFIG_VB) || defined (CONFIG_VB_2))
+		case CNS3XXX_BCM53115M_REG_READ:
+		{
+			return bcm53115M_reg_read_ioctl(ifr);
+		}
+		case CNS3XXX_BCM53115M_REG_WRITE:
+		{
+			return bcm53115M_reg_write_ioctl(ifr);
+		}
 
-	// 1. delete old arl mac entry
-	// 2. add new arl mac entry
-	// 3. copy new mac to netdev field
+#endif
 
-	if (priv->net_device_priv->arl_table_entry) {
-		cns3xxx_arl_table_invalid(priv->net_device_priv->arl_table_entry);
-		memcpy(priv->net_device_priv->arl_table_entry->mac, addr->sa_data, dev->addr_len);
-		//print_arl_table_entry(priv->net_device_priv->arl_table_entry);
-		cns3xxx_arl_table_add(priv->net_device_priv->arl_table_entry);
-#if defined (CONFIG_CNS3XXX_SPPE)
-		/* If IVL, we need additional ARLs for CPU to PPE */
-		if (MAC_GLOB_CFG_REG & (0x1 << 7)) {
-			ARLTableEntry arl;
-			arl = *(priv->net_device_priv->arl_table_entry);
-			arl.vid = (MAC2_CPU_PVID_REG & 0xFFF); 
-			cns3xxx_arl_table_add(&arl);
+#if 0
+		case CNS3XXX_RXRING_STATUS:
+		{
+			return get_rxring(ifr);
 		}
 #endif
+		case CNS3XXX_DUMP_MIB_COUNTER:
+		{
+			return dump_mib_counter(ifr);
+		}
+	
 
-	}
-	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+		default:
+		{
+			printk("[kernel mode] don't match any command\n");
+			break;
+		}
 
-	spin_unlock_irq(&priv->lock);
+	} // end switch (ioctl_cmd) 
 	return 0;
 }
+#define ceil(x, y) \
+	({ unsigned long __x = (x), __y = (y); (__x + __y - 1) / __y; })
 
 #ifdef CONFIG_CNS3XXX_NAPI
-static int cns3xxx_poll(struct napi_struct *napi, int budget)
+static int cns3xxx_poll(struct napi_struct *napi, int weight) //KH_POLL
+{
+      /* -------------------------------------------------------------------------- */
+	int work                     = 0;
+	unsigned int fssd_index      = get_rx_hw_index_by_reg(0);
+	RXBuffer volatile *rx_buffer = rx_array[rx_array_index];
+	RXDesc   *rx_desc;           //modify by Gopal
+	RXDesc   tmp_desc;           //modify by Gopal
+	unsigned int i               = 0, j = 0, jb_pk_rec = 0;
+	int rxcount                  = fssd_index - rx_array_index;
+	struct sk_buff *skb          = 0;
+	struct sk_buff *buffer_skb   = 0;
+	unsigned int len             = 0;
+	rx_desc                      = &tmp_desc; //modify by Gopal
+	*rx_desc                     =  *(rx_buffer->rx_desc); //modify by Gopal
+
+	if (rxcount<0) 
+		rxcount += (rx_eor+1);
+	else if(rxcount==0)	{
+		if (rx_desc->cown==0) 
+			goto poll_done;
+		else 
+			rxcount = rx_eor+1;
+	}
+	
+	for(i=0;i<rxcount;i++)
+	{
+		if(rx_desc->cown==1)
+		{	
+			// Mac port set 9014 and max_mtu set 1500 will panic so need to check mtu and rxdesc sdl 
+			if ( rx_desc->sdl > max_mtu ){
+				jb_pk_rec = (rx_desc->sdl + max_mtu -1) / max_mtu;
+				for( j=0 ; j < jb_pk_rec ;  j++){
+					rx_desc->sdl   = max_mtu;
+					rx_desc->cown  = 0;
+					*(rx_buffer->rx_desc) =  *rx_desc; //modify by Gopal
+					rx_array_index = (rx_array_index+1)&(rx_eor);
+					rx_buffer      = rx_array[rx_array_index];
+					*rx_desc       = *(rx_buffer->rx_desc); //modify by Gopal
+				}
+				i += (jb_pk_rec - 1);
+				continue;
+			}
+			buffer_skb = rx_buffer->skb;
+
+			// sp:
+			// 0 - mac port 0
+			// 1 - mac port 1
+			// 4 - mac port 2
+			buffer_skb->dev = PORT1_NETDEV;
+			//printk("rx_desc->sp = %x\n",rx_desc->sp);
+			switch (rx_desc->sp) {
+			case 0:
+				buffer_skb->dev = PORT0_NETDEV;
+ 				break;
+			case 1:
+				buffer_skb->dev = PORT1_NETDEV;
+				break;
+			case 4:
+				buffer_skb->dev = PORT2_NETDEV;
+				break;
+			}
+			intr_priv = netdev_priv(buffer_skb->dev);
+			skb = dev_alloc_skb(max_mtu + 2 + RX_SDP_ALIGN);
+			if(unlikely(!skb))
+			{
+				printk("\n dev_alloc_skb fail!! while allocate RFD ring !!\n");
+				rx_desc->cown  = 0;
+				*(rx_buffer->rx_desc) =  *rx_desc; //modify by Gopal
+				goto poll_done;
+			}
+			else
+			{
+			        unsigned int align = CPU_CACHE_ALIGN((u32)skb->data);
+			        skb_reserve(skb, align-(u32)skb->data + NET_IP_ALIGN);
+				len             = rx_desc->sdl;
+#ifdef CNS3XXX_NON_NIC_MODE_8021Q
+				if (cns3xxx_is_untag_packet(rx_desc) == 1)
+					take_off_vlan_header(buffer_skb);
+#endif
+				skb_put(buffer_skb, len);
+				if(rx_desc->prot<=6&&rx_desc->l4f==0) 
+					buffer_skb->ip_summed = CHECKSUM_UNNECESSARY;
+				else 
+					buffer_skb->ip_summed = CHECKSUM_NONE;
+				buffer_skb->protocol           = eth_type_trans(buffer_skb, buffer_skb->dev);
+				buffer_skb->dev->last_rx       = jiffies;
+				intr_priv->stats.rx_packets++;
+				intr_priv->stats.rx_bytes      += len;
+				netif_receive_skb(buffer_skb);
+				rx_buffer->skb = skb;
+				rx_desc->sdp   = dma_map_single(NULL, skb->data,max_mtu, DMA_FROM_DEVICE);
+				rx_desc->sdl   = max_mtu;
+				rx_desc->cown  = 0; // set cbit to 0 
+				work++;
+				*(rx_buffer->rx_desc) =  *rx_desc; //modify by Gopal
+				rx_array_index = (rx_array_index+1)&(rx_eor);
+				rx_buffer      = rx_array[rx_array_index];
+				*rx_desc       = *(rx_buffer->rx_desc); //modify by Gopal
+			}
+		}
+		else
+		{
+//			printk("%s %d cown = 0 \n",__FUNCTION__,__LINE__);
+			break;
+		}
+	}
+
+poll_done:
+      /* -------------------------------------------------------------------------- */
+      if(!work)
+         {
+            napi_complete(napi);
+            cns3xxx_write_pri_mask(0xf0);
+         }
+      /* -------------------------------------------------------------------------- */
+      FS_DMA_CTRL0_REG = 1;
+      /* -------------------------------------------------------------------------- */
+      return work;
+      /* -------------------------------------------------------------------------- */
+   }
+/* --------------------------------------------------------------------------------------------------- */
+#if 0
+static int cns3xxx_poll_LSDK(struct napi_struct *napi, int budget)
 {
+
 	CNS3XXXPrivate *sp = container_of(napi, CNS3XXXPrivate, napi);
 	int work_done = 0;
 	int work_to_do = budget; // define minima value
@@ -1894,6 +3751,7 @@
 	return work_done;
 }
 #endif
+#endif
 
 static struct net_device_stats *cns3xxx_get_stats(struct net_device *dev)
 {
@@ -1901,17 +3759,74 @@
 
 	return &priv->stats;
 }
-
+/* --------------------------------------------------------------------------------------------------------------- */
 static int cns3xxx_change_mtu(struct net_device *dev, int new_mtu)
-{
-	if (new_mtu < cns3xxx_min_mtu() || new_mtu > cns3xxx_max_mtu())
-		return -EINVAL;
-
-	dev->mtu = new_mtu;
-
-	return 0;
-}
-
+   {
+      /* --------------------------------------------------------------------------------------------------------- */
+//      if(new_mtu < cns3xxx_min_mtu() || new_mtu > cns3xxx_max_mtu()){return -EINVAL;}
+      CNS3XXXPrivate *priv  = netdev_priv(dev);
+      unsigned int pmap = priv->net_device_priv->pmap;
+      /* --------------------------------------------------------------------------------------------------------- */
+      if(new_mtu<64)
+         {
+            printk(" MTU: the %d is too small , re-set to %d\n",new_mtu,64);
+            new_mtu = 64;
+         }
+      /* --------------------------------------------------------------------------------------------------------- */
+      if(new_mtu>MAX_PACKET_LEN)
+         {
+            printk(" MTU: the %d is too large, re-set to %d\n",new_mtu,MAX_PACKET_LEN);
+            new_mtu = MAX_PACKET_LEN;
+         }
+      /* --------------------------------------------------------------------------------------------------------- */
+      cns3xxx_close(dev);
+      /* --------------------------------------------------------------------------------------------------------- */
+      dev->mtu = new_mtu;
+      /* --------------------------------------------------------------------------------------------------------- */
+//      printk("dev: %d\n",pmap);
+      dev_mtu[pmap] = new_mtu;
+      /* --------------------------------------------------------------------------------------------------------- */      
+      if(new_mtu>=1500)
+         {
+            unsigned int ratio = (unsigned int)(new_mtu/1500);
+            if(ratio>5)
+               {
+                  rx_eor = RX_DESC_SIZE/8 - 1;
+                  tx_eor = TX_DESC_SIZE/8 - 1;
+               }
+              else
+               {
+                 if(ratio>3)
+                    {
+                       rx_eor = RX_DESC_SIZE/4 - 1;
+                       tx_eor = TX_DESC_SIZE/4 - 1;
+                    }
+                 else
+                    {
+                       if(ratio>1)
+                          {
+                             rx_eor = RX_DESC_SIZE/2 - 1;
+                             tx_eor = TX_DESC_SIZE/2 - 1;
+                          }
+                       else
+                          {
+                             rx_eor = RX_DESC_SIZE - 1;
+                             tx_eor = TX_DESC_SIZE - 1;
+                          }
+                    }
+               }
+         }
+      /* --------------------------------------------------------------------------------------------------------- */	
+      cns3xxx_open(dev);
+      reset_tx_rx_ring();
+      /* --------------------------------------------------------------------------------------------------------- */
+//      tx_array_index = 0;
+//      rx_array_index = 0;
+      /* --------------------------------------------------------------------------------------------------------- */
+      return 0;
+      /* --------------------------------------------------------------------------------------------------------- */
+   }
+/* --------------------------------------------------------------------------------------------------------------- */
 static void cns3xxx_timeout(struct net_device *dev)
 {
 	printk("%s:cns3xxx gsw timeout\n", dev->name);
@@ -1920,32 +3835,28 @@
 	dev->trans_start = jiffies;
 }
 
-int cns3xxx_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
-
-#ifdef LINUX2631
 static const struct net_device_ops cns3xxx_netdev_ops = {
-	.ndo_open               = cns3xxx_open,
-	.ndo_stop               = cns3xxx_close,
-	.ndo_start_xmit         = cns3xxx_send_packet,
-	//.ndo_validate_addr      = eth_validate_addr,
-	//.ndo_set_multicast_list = cns3xxx_set_multicast_list,
-	.ndo_set_mac_address    = cns3xxx_set_mac_addr,
-	.ndo_change_mtu         = cns3xxx_change_mtu,
-	.ndo_do_ioctl           = cns3xxx_do_ioctl,
-	.ndo_tx_timeout         = cns3xxx_timeout,
+        .ndo_open               = cns3xxx_open,
+        .ndo_stop               = cns3xxx_close,
+        .ndo_start_xmit         = cns3xxx_send_packet,
+        //.ndo_validate_addr      = eth_validate_addr,
+        //.ndo_set_multicast_list = cns3xxx_set_multicast_list,
+        .ndo_set_mac_address    = cns3xxx_set_mac_addr,
+        .ndo_change_mtu         = cns3xxx_change_mtu,
+        .ndo_do_ioctl           = cns3xxx_do_ioctl,
+        .ndo_tx_timeout         = cns3xxx_timeout,
 	.ndo_get_stats		= cns3xxx_get_stats,
 
 #if defined(CNS3XXX_VLAN_8021Q)
-	.ndo_vlan_rx_register   = cns3xxx_vlan_rx_register,
-	//.ndo_vlan_rx_add_vid    = e1000_vlan_rx_add_vid,
-	.ndo_vlan_rx_kill_vid   = cns3xxx_vlan_rx_kill_vid,
+        .ndo_vlan_rx_register   = cns3xxx_vlan_rx_register,
+        //.ndo_vlan_rx_add_vid    = e1000_vlan_rx_add_vid,
+        .ndo_vlan_rx_kill_vid   = cns3xxx_vlan_rx_kill_vid,
 #endif
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller    = cns3xxx_netpoll,
+        .ndo_poll_controller    = cns3xxx_netpoll,
 #endif
 };
-#endif // LINUX2631
 
 static int __init cns3xxx_probe(RingInfo ring_info)
 {
@@ -1956,15 +3867,7 @@
 	int i=0, err=0;
 	struct net_device *netdev=0;
 	CNS3XXXPrivate *priv=0;
-	struct sockaddr sock_addr;
-#ifdef CONFIG_CNS3XXX_ETHADDR_IN_FLASH
-    u8 mac_int[6];
-    int val_len;
-    int do_new_mac = 0;
-    if (0 == init_mtd_env()) {
-        do_new_mac = 1;
-    }
-#endif
+        struct sockaddr sock_addr;
 
 	for (i=0 ; i < netdev_size ; ++i) {
 
@@ -1973,10 +3876,14 @@
 			err = -ENOMEM;
 			goto err_alloc_etherdev;
 		}
+		
+		//netdev->mtu = MAX_PACKET_LEN;//KH
+		netdev->mtu = 1500 ; //KH
+		
 		if (net_device_prive[i].name)
 			strcpy(netdev->name, net_device_prive[i].name);
 
-		net_device_prive[i].netdev = netdev;
+
 		net_dev_array[net_device_prive[i].vlan_tag] = netdev;
 		//printk("\tnet_dev_array[%d]: %x\n", net_device_prive[i].vlan_tag , netdev);
 		if (intr_netdev==0)
@@ -1991,33 +3898,16 @@
 		priv->num_tx_queues = ring_info.num_tx_queues;
 		priv->rx_ring = ring_info.rx_ring;
 		priv->tx_ring = ring_info.tx_ring;
-		priv->rx_en=1;
+
 
 		priv->net_device_priv = &net_device_prive[i];
 		//printk("net_device_prive[i].pmap : %x\n", net_device_prive[i].pmap);
 
 		// set netdev MAC address
-#if defined (CONFIG_CNS3XXX_ETHADDR_IN_FLASH)
-		if (do_new_mac) {
-			char name[20];
-			sprintf(name, "ethaddr%d=", i);
-			if (0 == fmg_get(name,&val_len)) {
-				mac_str_to_int(ethaddr, val_len,mac_int, 6);
-				memcpy(sock_addr.sa_data, mac_int, 6);
-			} else {
-				memcpy(sock_addr.sa_data, net_device_prive[i].mac, 6);
-			}
-		} else {
-			memcpy(sock_addr.sa_data, net_device_prive[i].mac, 6);
-		}
-#else
-		memcpy(sock_addr.sa_data, net_device_prive[i].mac, 6);
-#endif
-		cns3xxx_set_mac_addr(netdev, &sock_addr);
+	        memcpy(sock_addr.sa_data, net_device_prive[i].mac, 6);
+	        cns3xxx_set_mac_addr(netdev, &sock_addr);
 
-#ifdef LINUX2631
 		netdev->netdev_ops = &cns3xxx_netdev_ops;
-#endif
 
 		cns3xxx_set_ethtool_ops(netdev);
 #ifdef LINUX2627
@@ -2038,10 +3928,8 @@
 
 #if defined(CNS3XXX_TX_HW_CHECKSUM)
 		netdev->features |= NETIF_F_IP_CSUM;
-	#ifndef CNS3XXX_SG_DISABLE
-		netdev->features |= NETIF_F_SG;
-	#endif
 #endif
+		netdev->features |= NETIF_F_SG;
 
 #ifdef CONFIG_CNS3XXX_NAPI
 		//printk("napi netdev: %s\n", netdev->name);
@@ -2112,100 +4000,94 @@
 }
 #endif
 
-static int cns3xxx_pse_regs_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+static int cns3xxx_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
 {
 	int num = 0;
-	int i=0;
+	int i=0,sum=0;
 
-	for (i=0x00 ; i <= 0x84 ; i+=4)
-		num += sprintf(page + num, "offset %#x: %#x\n", i, SWITCH_REG_VALUE(i) );
-	for (i=0xd0 ; i <= 0xf8 ; i+=4)
-		num += sprintf(page + num, "offset %#x: %#x\n", i, SWITCH_REG_VALUE(i) );
-	for (i=0x100 ; i <= 0x164 ; i+=4)
-		num += sprintf(page + num, "offset %#x: %#x\n", i, SWITCH_REG_VALUE(i) );
-	num += sprintf(page + num, "IOCDA_REG:  %#x\n", IOCDA_REG);
+	num += sprintf(page + num, "tx_array_index = %d\n",tx_array_index); //KH
+	num += sprintf(page + num, "tx_hw_index    = %d\n",(TS_DESC_PTR0_REG - TS_DESC_BASE_ADDR0_REG)/sizeof(TXDesc));
+	num += sprintf(page + num, "   TS_DESC_PTR0_REG       = %x\n",TS_DESC_PTR0_REG);
+	num += sprintf(page + num, "   TS_DESC_BASE_ADDR0_REG = %x\n",TS_DESC_BASE_ADDR0_REG);
+
+	sum = 0;
+	for(i=0;i<tx_eor;i++)
+	   {
+	      TXBuffer *tx_buffer = tx_array[i];
+	      if(tx_buffer->tx_desc->cown==1){sum++;}
+	   }
+
+	num += sprintf(page + num ,"tx_eor         = %d/cown=%d\n\n",tx_eor,sum);
+
+	
+	num += sprintf(page + num, "rx_array_index = %d\n",rx_array_index);
+	num += sprintf(page + num, "rx_hw_index    = %d\n",(FS_DESC_PTR0_REG - FS_DESC_BASE_ADDR0_REG)/sizeof(RXDesc));
+	num += sprintf(page + num, "   FS_DESC_PTR0_REG       = %x\n",FS_DESC_PTR0_REG);
+	num += sprintf(page + num, "   FS_DESC_BASE_ADDR0_REG = %x\n",FS_DESC_BASE_ADDR0_REG);
+	num += sprintf(page + num ,"rx_eor         = %d\n",rx_eor);
+
+        if(1)
+           {
+              unsigned int RXOK[4] = {0,0,0,0} , RXDROP[4] = {0,0,0,0} , RXCRC[4] = {0,0,0,0};
+              unsigned int TXOK[4] = {0,0,0,0} , TXDROP[4] = {0,0,0,0};
+              
+              RXOK[0]   += SWITCH_REG_VALUE(0x300);
+              RXDROP[0] += SWITCH_REG_VALUE(0x310);
+              RXCRC[0]  += SWITCH_REG_VALUE(0x314);
+              TXOK[0]   += SWITCH_REG_VALUE(0x32c);
+              RXOK[1]   += SWITCH_REG_VALUE(0x400);
+              RXDROP[1] += SWITCH_REG_VALUE(0x410);
+              RXCRC[1]  += SWITCH_REG_VALUE(0x414);
+              TXOK[1]   += SWITCH_REG_VALUE(0x42c);
+              RXOK[2]   += SWITCH_REG_VALUE(0x600);
+              RXDROP[2] += SWITCH_REG_VALUE(0x610);
+              RXCRC[2]  += SWITCH_REG_VALUE(0x614);
+              TXOK[2]   += SWITCH_REG_VALUE(0x62c);
+              TXOK[3]   += SWITCH_REG_VALUE(0x500);
+              TXDROP[3] += SWITCH_REG_VALUE(0x508);
+              RXOK[3]   += SWITCH_REG_VALUE(0x524);              
+              
+              num += sprintf(page + num , "         rx_ok       rx_drop        rx_crc     tx_ok\n");
+              num += sprintf(page + num , " mac0:   %-10d  %-10d     %-10d %-10d\n",RXOK[0],RXDROP[0],RXCRC[0],TXOK[0]);
+              num += sprintf(page + num , " mac1:   %-10d  %-10d     %-10d %-10d\n",RXOK[1],RXDROP[1],RXCRC[1],TXOK[1]);     
+              num += sprintf(page + num , " mac2:   %-10d  %-10d     %-10d %-10d\n\n",RXOK[2],RXDROP[2],RXCRC[2],TXOK[2]);                   
+              num += sprintf(page + num , "         fs_ok       ts_ok          ts_drop\n");
+              num += sprintf(page + num , " cpu0:   %-10d  %-10d     %-10d\n\n",RXOK[3],TXOK[3],TXDROP[3]);
+           }
+        
+        if(1)
+           {
+              RXBuffer *rx_buffer = rx_array[10];
+              num += sprintf(page + num , "max_mtu = %d\n",max_mtu);
+              num += sprintf(page + num , "p0: %d , p1: %d  , p2: %d\n",dev_mtu[0],dev_mtu[2],dev_mtu[16]);
+              num += sprintf(page + num , "rx_buffer[10]->rx_desc->sdl = %d\n",rx_buffer->rx_desc->sdl);
+              num += sprintf(page + num , "TC_CTRL_REG: %x\n\n",TC_CTRL_REG);
+              
+           }
+           
+        if(1)
+           {
+              int i = 0;
+              RXBuffer *rx_buffer;
+              TXBuffer *tx_buffer;
+              for(i=0;i<RX_DESC_SIZE;i++)
+                 {
+                    rx_buffer = rx_array[i];
+                    if(rx_buffer->rx_desc->eor ==1){break;}
+                 }
+              num += sprintf(page + num , "real rx_eor = %d\n",i);
+
+              for(i=0;i<TX_DESC_SIZE;i++)
+                 {
+                    tx_buffer = tx_array[i];
+                    if(tx_buffer->tx_desc->eor ==1){break;}
+                 }
+              num += sprintf(page + num , "real tx_eor = %d\n\n",i);
+           }
 
-	return num;
-}
 
-static int cns3xxx_pse_counter_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-	int num = 0;
-#ifdef CNS3XXX_MAC0_MIB_COUNTER
-	num += sprintf(page + num, "C_RXOKPKT_MAC0_REG: %d\n", C_RXOKPKT_MAC0_REG);
-	num += sprintf(page + num, "C_RXOKBYTE_MAC0_REG  : %d\n", C_RXOKBYTE_MAC0_REG  );
-	num += sprintf(page + num, "C_RXRUNT_MAC0_REG  : %d\n", C_RXRUNT_MAC0_REG  );
-	num += sprintf(page + num, "C_RXLONG_MAC0_REG  : %d\n", C_RXLONG_MAC0_REG  );
-	num += sprintf(page + num, "C_RXDROP_MAC0_REG  : %d\n", C_RXDROP_MAC0_REG  );
-	num += sprintf(page + num, "C_RXCRC_MAC0_REG  : %d\n", C_RXCRC_MAC0_REG  );
-	num += sprintf(page + num, "C_RXARLDROP_MAC0_REG  : %d\n", C_RXARLDROP_MAC0_REG  );
-	num += sprintf(page + num, "C_VIDROP_MAC0_REG  : %d\n", C_VIDROP_MAC0_REG  );
-	num += sprintf(page + num, "C_VEDROP_MAC0_REG  : %d\n", C_VEDROP_MAC0_REG  );
-	num += sprintf(page + num, "C_RXRL_MAC0_REG  : %d\n", C_RXRL_MAC0_REG  );
-	num += sprintf(page + num, "C_RXPAUSE_MAC0_REG  : %d\n", C_RXPAUSE_MAC0_REG  );
-
-	num += sprintf(page + num, "C_TXOKPKT_MAC0_REG  : %d\n", C_TXOKPKT_MAC0_REG  );
-	num += sprintf(page + num, "C_TXOKBYTE_MAC0_REG  : %d\n", C_TXOKBYTE_MAC0_REG  );
-	num += sprintf(page + num, "C_TXPAUSECOL_MAC0_REG  : %d\n", C_TXPAUSECOL_MAC0_REG  );
-#endif
-
-#ifdef CNS3XXX_MAC1_MIB_COUNTER
-	num += sprintf(page + num, "C_RXOKPKT_MAC1_REG  : %d\n", C_RXOKPKT_MAC1_REG  );
-	num += sprintf(page + num, "C_RXOKBYTE_MAC1_REG  : %d\n", C_RXOKBYTE_MAC1_REG  );
-	num += sprintf(page + num, "C_RXRUNT_MAC1_REG  : %d\n", C_RXRUNT_MAC1_REG  );
-	num += sprintf(page + num, "C_RXLONG_MAC1_REG  : %d\n", C_RXLONG_MAC1_REG  );
-	num += sprintf(page + num, "C_RXDROP_MAC1_REG  : %d\n", C_RXDROP_MAC1_REG  );
-	num += sprintf(page + num, "C_RXCRC_MAC1_REG  : %d\n", C_RXCRC_MAC1_REG  );
-	num += sprintf(page + num, "C_RXARLDROP_MAC1_REG  : %d\n", C_RXARLDROP_MAC1_REG  );
-	num += sprintf(page + num, "C_VIDROP_MAC1_REG  : %d\n", C_VIDROP_MAC1_REG  );
-	num += sprintf(page + num, "C_VEDROP_MAC1_REG  : %d\n", C_VEDROP_MAC1_REG  );
-	num += sprintf(page + num, "C_RXRL_MAC1_REG  : %d\n", C_RXRL_MAC1_REG  );
-	num += sprintf(page + num, "C_RXPAUSE_MAC1_REG  : %d\n", C_RXPAUSE_MAC1_REG  );
-
-	num += sprintf(page + num, "C_TXOKPKT_MAC1_REG  : %d\n", C_TXOKPKT_MAC1_REG  );
-	num += sprintf(page + num, "C_TXOKBYTE_MAC1_REG  : %d\n", C_TXOKBYTE_MAC1_REG  );
-	num += sprintf(page + num, "C_TXPAUSECOL_MAC1_REG  : %d\n", C_TXPAUSECOL_MAC1_REG  );
-#endif
-
-#ifdef CNS3XXX_CPU_MIB_COUNTER
-	num += sprintf(page + num, "C_TSOKPKT_CPU_REG  : %d\n", C_TSOKPKT_CPU_REG  );
-	num += sprintf(page + num, "C_TSOKBYTE_CPU_REG  : %d\n", C_TSOKBYTE_CPU_REG  );
-	num += sprintf(page + num, "C_TSRUNT_CPU_REG  : %d\n", C_TSRUNT_CPU_REG  );
-	num += sprintf(page + num, "C_TSLONG_CPU_REG  : %d\n", C_TSLONG_CPU_REG  );
-	num += sprintf(page + num, "C_TSNODSTDROP_CPU_REG  : %d\n", C_TSNODSTDROP_CPU_REG  );
-	num += sprintf(page + num, "C_TSARLDROP_CPU_REG  : %d\n", C_TSARLDROP_CPU_REG  );
-	num += sprintf(page + num, "C_TSVIDROP_CPU_REG  : %d\n", C_TSVIDROP_CPU_REG  );
-	num += sprintf(page + num, "C_TSVEDROP_CPU_REG  : %d\n", C_TSVEDROP_CPU_REG  );
-	num += sprintf(page + num, "C_TSRL_CPU_REG  : %d\n", C_TSRL_CPU_REG  );
-
-	num += sprintf(page + num, "C_FSOKPKT_CPU_REG  : %d\n", C_FSOKPKT_CPU_REG  );
-	num += sprintf(page + num, "C_FSOKBYTE_CPU_REG  : %d\n", C_FSOKBYTE_CPU_REG  );
-#endif
-
-#ifdef CNS3XXX_MAC2_MIB_COUNTER
-	num += sprintf(page + num, "C_RXOKPKT_MAC2_REG  : %d\n", C_RXOKPKT_MAC2_REG  );
-	num += sprintf(page + num, "C_RXOKBYTE_MAC2_REG  : %d\n", C_RXOKBYTE_MAC2_REG  );
-	num += sprintf(page + num, "C_RXRUNT_MAC2_REG  : %d\n", C_RXRUNT_MAC2_REG  );
-	num += sprintf(page + num, "C_RXLONG_MAC2_REG  : %d\n", C_RXLONG_MAC2_REG  );
-	num += sprintf(page + num, "C_RXDROP_MAC2_REG  : %d\n", C_RXDROP_MAC2_REG  );
-	num += sprintf(page + num, "C_RXCRC_MAC2_REG  : %d\n", C_RXCRC_MAC2_REG  );
-	num += sprintf(page + num, "C_RXARLDROP_MAC2_REG  : %d\n", C_RXARLDROP_MAC2_REG  );
-	num += sprintf(page + num, "C_VIDROP_MAC2_REG  : %d\n", C_VIDROP_MAC2_REG  );
-	num += sprintf(page + num, "C_VEDROP_MAC2_REG  : %d\n", C_VEDROP_MAC2_REG  );
-	num += sprintf(page + num, "C_RXRL_MAC2_REG  : %d\n", C_RXRL_MAC2_REG  );
-	num += sprintf(page + num, "C_RXPAUSE_MAC2_REG  : %d\n", C_RXPAUSE_MAC2_REG  );
-
-	num += sprintf(page + num, "C_TXOKPKT_MAC2_REG  : %d\n", C_TXOKPKT_MAC2_REG  );
-	num += sprintf(page + num, "C_TXOKBYTE_MAC2_REG  : %d\n", C_TXOKBYTE_MAC2_REG  );
-	num += sprintf(page + num, "C_TXPAUSECOL_MAC2_REG  : %d\n", C_TXPAUSECOL_MAC2_REG  );
-#endif
 	return num;
-}
 
-static int cns3xxx_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-	int num = 0;
-	//int i=0;
 
 #if defined(CNS3XXX_VLAN_8021Q)
 	num += sprintf(page + num, "CNS3XXX_VLAN_8021Q Enable\n");
@@ -2279,27 +4161,66 @@
 	num += sprintf(page + num, "g_ring_info.num_tx_queues: %d\n", g_ring_info.num_tx_queues);
 	num += sprintf(page + num, "g_ring_info.rx_ring: %p\n", g_ring_info.rx_ring);
 	num += sprintf(page + num, "g_ring_info.tx_ring: %p\n", g_ring_info.tx_ring);
+#ifdef DEBUG_RX_PROC
+if (show_rx_proc)
+{ // for debug
+	int i=0, j=0;
+	RXBuffer *rx_buffer = 0;
 
-	num += sprintf(page + num, "tx_ring_index: %d\n", tx_ring_index);
+	if (g_ring_info.rx_ring) {
+		for (i=0 ; i < g_ring_info.num_rx_queues ; ++i) {
+			rx_buffer = get_rx_ring_head(g_ring_info.rx_ring+i);
 
+			if (rx_buffer==0)
+				break;
+
+			num += sprintf(page + num, "rx ring ## %d\n", i);
+			num += sprintf(page + num, "get_rx_ring_size(rx_ring): %d\n", get_rx_ring_size(g_ring_info.rx_ring+i));
+			num += sprintf(page + num, "rx cur index: %d\n", get_rx_cur_index(g_ring_info.rx_ring+i));
+			num += sprintf(page + num, "rx hw index: %d\n", get_rx_hw_index_by_reg(i) );
+			for (j=0 ; j < get_rx_ring_size(g_ring_info.rx_ring+i); ++j) {
+				num += sprintf(page + num, "#%d: rx_buffer: %p ## rx desc: %p ## rx_buffer->rx_desc->cown: %d\n", j, rx_buffer, rx_buffer->rx_desc, rx_buffer->rx_desc->cown);
+				++rx_buffer;
+			}
+		}
 
-//#ifdef CONFIG_CNS3XXX_PORT_BASE
-	if(is_config_cns3xxx_port_base()) {
-		num += sprintf(page + num, "CONFIG_PORT_BASE\n");
-	}
-//#endif
 
-//#ifdef  CONFIG_CNS3XXX_VLAN_BASE
-	if(is_config_cns3xxx_vlan_base()) {
-		num += sprintf(page + num, "CONFIG_VLAN_BASE\n");
 	}
-//#endif
+}
+#endif
+
+	num += sprintf(page + num, "ring_index: %d\n", ring_index);
+#ifdef DEBUG_TX_PROC
+if (show_tx_proc)
+{ // for debug
+	int i=0, j=0;
+	TXBuffer *buffer = 0;
+
+	//num += sprintf(page + num, "dscp: %#x\n", dscp);
+	num += sprintf(page + num, "TS_DESC_BASE_ADDR0_REG: %#x\n", TS_DESC_BASE_ADDR0_REG);
+	num += sprintf(page + num, "TS_DESC_PTR0_REG: %#x\n", TS_DESC_PTR0_REG);
+	if (g_ring_info.tx_ring) {
+		for (i=0 ; i < g_ring_info.num_tx_queues ; ++i) {
+			buffer = get_tx_ring_head(g_ring_info.tx_ring+i);
+
+			if (buffer==0)
+				break;
+
+			num += sprintf(page + num, "tx ring ## %d\n", i);
+			num += sprintf(page + num, "get_tx_ring_size(tx_ring): %d\n", get_tx_ring_size(g_ring_info.tx_ring+i));
+			num += sprintf(page + num, "tx cur index: %d\n", get_tx_cur_index(g_ring_info.tx_ring+i));
+			num += sprintf(page + num, "cns3xxx_get_tx_hw_index 0 : %d\n", cns3xxx_get_tx_hw_index(0));
+			//num += sprintf(page + num, "rx hw index: %d\n", get_rx_hw_index_by_reg(i) );
+			for (j=0 ; j < get_tx_ring_size(g_ring_info.tx_ring+i); ++j) {
+				num += sprintf(page + num, "#%d: tx desc: %p ## buffer->tx_desc->cown: %d ## tx_buffer: %p ## buffer->skb :%p\n", j, buffer->tx_desc, buffer->tx_desc->cown, buffer, buffer->skb);
+				++buffer;
+			}
+		}
+
 
-//#ifdef CONFIG_HAVE_VLAN_TAG
-	if(is_config_have_vlan_tag()) {
-		num += sprintf(page + num, "CONFIG_HAVE_VLAN_TAG\n");
 	}
-//#endif
+}
+#endif
 
 #ifdef DEBUG_PRIO_IPDSCR
 {
@@ -2376,14 +4297,14 @@
 	}
 #endif	
 	
-	if(jumbo_frame) {
-		num += sprintf(page + num, "CNS3XXX JUMBO FRAME Support\n");
-	} else {
-		num += sprintf(page + num, "CNS3XXX JUMBO FRAME Not Support\n");
-	}
-#ifdef CNS3XXX_SG_DEBUG
-	num += sprintf(page + num, "sg_time: %d\n", sg_time);
-#endif
+	num += sprintf(page + num, "tx_array_index = %d\n",tx_array_index); //KH
+	num += sprintf(page + num, "rx_array_index = %d\n",rx_array_index);
+
+	num += sprintf(page + num, "tx_hw_index    = %d\n",(TS_DESC_PTR0_REG - TS_DESC_BASE_ADDR0_REG)/sizeof(TXDesc));
+	num += sprintf(page + num, "rx_hw_index    = %d\n",(FS_DESC_PTR0_REG - FS_DESC_BASE_ADDR0_REG)/sizeof(RXDesc));
+
+	
+
 	return num;
 }
 
@@ -2400,10 +4321,20 @@
 		        	MAC2_CFG_REG |= (1 << 15);
 		}
 
+		if (buffer[0] == 'r' && buffer[1] == 'x') {
+			show_rx_proc = simple_strtol(buffer+3, 0, 0);
+			printk("show_rx_proc: %d\n", show_rx_proc);
+			return count;
+		}
+		if (buffer[0] == 't' && buffer[1] == 'x') {
+			show_tx_proc = simple_strtol(buffer+3, 0, 0);
+			printk("show_tx_proc: %d\n", show_tx_proc);
+			return count;
+		}
 #ifdef CNS3XXX_CONFIG_CHANGE_TX_RING
 		if (buffer[0] == 't') {
-			tx_ring_index = buffer[2] - '0';
-			printk("tx_ring_index: %d\n", tx_ring_index);
+			ring_index = buffer[2] - '0';
+			printk("ring_index: %d\n", ring_index);
 		}
 #endif
 
@@ -2462,231 +4393,32 @@
 		}
 
 	}
-	return count;
-}
-
-static void *dumpTXstart(struct seq_file *m, loff_t *pos);
-static void *dumpTXnext(struct seq_file *m, void *v, loff_t *pos);
-static void dumpTXstop(struct seq_file *m, void *v);
-static int dumpTXshow(struct seq_file *m, void *v);
-
-static void *dumpTXstart(struct seq_file *m, loff_t *pos)
-{
-	return *pos < 1 ? (void *)1 : NULL;
-}
-
-static void *dumpTXnext(struct seq_file *m, void *v, loff_t *pos)
-{
-	++*pos;
-	return NULL;
-}
-
-static void dumpTXstop(struct seq_file *m, void *v)
-{
-}
-
-static int dumpTXshow(struct seq_file *m, void *v)
-{
-	int i, j;
-	TXBuffer *tx_buffer;
-	TXDesc *tx_desc;
-
-	seq_printf(m, "g_ring_info.num_tx_queues: %d\n", g_ring_info.num_tx_queues);
-	if (g_ring_info.tx_ring) {
-		for (i=0 ; i < g_ring_info.num_tx_queues ; ++i) {
-			for (j=0 ; j < get_tx_ring_size(g_ring_info.tx_ring+i); ++j) {
-				tx_buffer = get_tx_ring_head(g_ring_info.tx_ring+i);
-				tx_buffer += j;
-				tx_desc = tx_buffer->tx_desc;
-				seq_printf(m,"idx: %d ", j);
-				if (tx_desc) {
-					seq_printf(m,"tx_desc: %p ", tx_desc);
-					seq_printf(m,"sdp: %x ", tx_desc->sdp);
-					seq_printf(m,"sdl: %d ", tx_desc->sdl);
-					seq_printf(m,"tco: %d ", tx_desc->tco);
-					seq_printf(m,"uco: %d ", tx_desc->uco);
-					seq_printf(m,"ico: %d ", tx_desc->ico);
-					seq_printf(m,"pri: %d ", tx_desc->pri);
-					seq_printf(m,"fp: %d ", tx_desc->fp);
-					seq_printf(m,"fr: %d ", tx_desc->fr);
-					seq_printf(m,"intr: %d ", tx_desc->interrupt);
-					seq_printf(m,"lsd: %d ", tx_desc->lsd);
-					seq_printf(m,"fsd: %d ", tx_desc->fsd);
-					seq_printf(m,"eor: %d ", tx_desc->eor);
-					seq_printf(m,"cown: %d\n", tx_desc->cown);
-
-					seq_printf(m,"ctv: %d ", tx_desc->ctv);
-					seq_printf(m,"stv: %d ", tx_desc->stv);
-					seq_printf(m,"sid: %d ", tx_desc->sid);
-					seq_printf(m,"inss: %d ", tx_desc->inss);
-					seq_printf(m,"dels: %d ", tx_desc->dels);
-					seq_printf(m,"pmap: %d ", tx_desc->pmap);
-					seq_printf(m,"mark: %d ", tx_desc->mark);
-					seq_printf(m,"ewan: %d ", tx_desc->ewan);
-					seq_printf(m,"fewan: %d\n", tx_desc->fewan);
-					
-					seq_printf(m,"c_vid: %d ", tx_desc->c_vid);
-					seq_printf(m,"c_cfs: %d ", tx_desc->c_cfs);
-					seq_printf(m,"c_pri: %d ", tx_desc->c_pri);
-					seq_printf(m,"s_vid: %d ", tx_desc->s_vid);
-					seq_printf(m,"s_dei: %d ", tx_desc->s_dei);
-					seq_printf(m,"s_pri: %d\n", tx_desc->s_pri);
-				}
-			} // for (j=0 ; j < get_tx_ring_size(g_ring_info.tx_ring+i); ++j) 
-		} // for (i=0 ; i < g_ring_info.num_tx_queues ; ++i) 
-	} // if (g_ring_info.tx_ring) 
-	
-	return 0;
-}
-
-const struct seq_operations dumpTX_ops = {
-	.start  = dumpTXstart,
-	.next = dumpTXnext,
-	.stop = dumpTXstop,
-	.show = dumpTXshow
-};
-
-static int dumpTX_ops_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &dumpTX_ops);
-}
-
-
-static const struct file_operations dumpTX_fs_ops= { 
-	.open           = dumpTX_ops_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = seq_release,
-};
-
-
-static void *dumpRXstart(struct seq_file *m, loff_t *pos);
-static void *dumpRXnext(struct seq_file *m, void *v, loff_t *pos);
-static void dumpRXstop(struct seq_file *m, void *v);
-static int dumpRXshow(struct seq_file *m, void *v);
-
-const struct seq_operations dumpRX_ops = {
-	.start  = dumpRXstart,
-	.next = dumpRXnext,
-	.stop = dumpRXstop,
-	.show = dumpRXshow
-};
-
-static int dumpRX_ops_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &dumpRX_ops);
-}
-
-static const struct file_operations dumpRX_fs_ops= {
-	.open           = dumpRX_ops_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = seq_release,
-};
-
-
-static void *dumpRXstart(struct seq_file *m, loff_t *pos)
-{
-	return *pos < 1 ? (void *)1 : NULL;
-}
-
-static void *dumpRXnext(struct seq_file *m, void *v, loff_t *pos)
-{
-	++*pos;
-	return NULL;
-}
 
-static void dumpRXstop(struct seq_file *m, void *v)
-{
-}
-
-static int dumpRXshow(struct seq_file *m, void *v)
-{
-	int i, j;
-	RXBuffer *rx_buffer;
-	RXDesc *rx_desc;
 
-	seq_printf(m, "g_ring_info.num_rx_queues: %d\n", g_ring_info.num_rx_queues);
-	if (g_ring_info.rx_ring) {
-		for (i=0 ; i < g_ring_info.num_rx_queues ; ++i) {
-			for (j=0 ; j < get_rx_ring_size(g_ring_info.rx_ring+i); ++j) {
-				rx_buffer = get_rx_ring_head(g_ring_info.rx_ring+i);
-				rx_buffer += j;
-				rx_desc = rx_buffer->rx_desc;
-				seq_printf(m,"idx: %d ", j);
-				if (rx_desc) {
-					seq_printf(m,"rx_desc: %p ", rx_desc);
-					seq_printf(m,"sdp: %x ", rx_desc->sdp);
-					seq_printf(m,"sdl: %d ", rx_desc->sdl);
-					seq_printf(m,"l4f: %d ", rx_desc->l4f);
-					seq_printf(m,"ipf: %d ", rx_desc->ipf);
-					seq_printf(m,"prot: %d ", rx_desc->prot);
-					seq_printf(m,"hr: %d ", rx_desc->hr);
-					seq_printf(m,"lsd: %d ", rx_desc->lsd);
-					seq_printf(m,"fsd: %d ", rx_desc->fsd);
-					seq_printf(m,"eor: %d ", rx_desc->eor);
-					seq_printf(m,"cown: %d\n", rx_desc->cown);
-
-					seq_printf(m,"ctv: %d ", rx_desc->ctv);
-					seq_printf(m,"stv: %d ", rx_desc->stv);
-					seq_printf(m,"unv: %d ", rx_desc->unv);
-					seq_printf(m,"iwan: %d ", rx_desc->iwan);
-					seq_printf(m,"exdv: %d ", rx_desc->exdv);
-					seq_printf(m,"sp: %d ", rx_desc->sp);
-					seq_printf(m,"crc_err: %d ", rx_desc->crc_err);
-					seq_printf(m,"un_eth: %d ", rx_desc->un_eth);
-					seq_printf(m,"tc: %d ", rx_desc->tc);
-					seq_printf(m,"ip_offset: %d\n", rx_desc->ip_offset);
-
-					seq_printf(m,"c_vid: %d ", rx_desc->c_vid);
-					seq_printf(m,"c_cfs: %d ", rx_desc->c_cfs);
-					seq_printf(m,"c_pri: %d ", rx_desc->c_pri);
-					seq_printf(m,"s_vid: %d ", rx_desc->s_vid);
-					seq_printf(m,"s_dei: %d ", rx_desc->s_dei);
-					seq_printf(m,"s_pri: %d\n", rx_desc->s_pri);
-				}
-			} // for (j=0 ; j < get_rx_ring_size(g_ring_info.rx_ring+i); ++j) 
-		} // for (i=0 ; i < g_ring_info.num_rx_queues ; ++i) 
-	} // if (g_ring_info.rx_ring) 
-	
-	return 0;
+	return count;
 }
 
 static int cns3xxx_proc_remove(void)
 {
-	remove_proc_entry("pse", cns3xxx_proc_dir);
-	remove_proc_entry("pse_regs", cns3xxx_proc_dir);
-	remove_proc_entry("pse_counter", cns3xxx_proc_dir);
-	remove_proc_entry("pse_tx_desc", cns3xxx_proc_dir);
-	remove_proc_entry("pse_rx_desc", cns3xxx_proc_dir);
-
-	return 0;
+        remove_proc_entry("pse", cns3xxx_proc_dir);
+        remove_proc_entry("pse_regs", cns3xxx_proc_dir);
+        remove_proc_entry("pse_counter", cns3xxx_proc_dir);
+        remove_proc_entry("pse_tx_desc", cns3xxx_proc_dir);
+        remove_proc_entry("pse_rx_desc", cns3xxx_proc_dir);
+        
+    		return 0;
 }
 
 static int __init cns3xxx_proc_init(void)
 {
 	struct proc_dir_entry *switch_proc_entry=0;
 		
-	switch_proc_entry = create_proc_entry("pse", S_IFREG | S_IRUGO, cns3xxx_proc_dir);
-	if (switch_proc_entry) {
-		switch_proc_entry->read_proc = cns3xxx_read_proc;
-		switch_proc_entry->write_proc = cns3xxx_write_proc;
-	}
-
-	switch_proc_entry = create_proc_entry("pse_counter", S_IFREG | S_IRUGO, cns3xxx_proc_dir);
-	if (switch_proc_entry) {
-		switch_proc_entry->read_proc = cns3xxx_pse_counter_read_proc;
-	}
-
-	switch_proc_entry = create_proc_entry("pse_regs", S_IFREG | S_IRUGO, cns3xxx_proc_dir);
-	if (switch_proc_entry) {
-		switch_proc_entry->read_proc = cns3xxx_pse_regs_read_proc;
-	}
-
-	proc_create("cns3xxx/pse_tx_desc", 0, NULL, &dumpTX_fs_ops);
-	proc_create("cns3xxx/pse_rx_desc", 0, NULL, &dumpRX_fs_ops);
-
-	return 1;
+        switch_proc_entry = create_proc_entry("gsw", S_IFREG | S_IRUGO, cns3xxx_proc_dir);
+        if (switch_proc_entry) {
+                switch_proc_entry->read_proc = cns3xxx_read_proc;
+                switch_proc_entry->write_proc = cns3xxx_write_proc;
+        }
+        return 1;
 }
 
 static int cns3xxx_notify_reboot(struct notifier_block *nb, unsigned long event, void *ptr)
@@ -2702,14 +4434,6 @@
 	enable_port(1, 0); 
 	enable_port(2, 0); 
 	enable_port(3, 0); 
-
-	// disable phy auto-poll
-	PHY_AUTO_ADDR_REG &= ~((1<<5) | (1<<13) | (1<<21));
-	//printk("disable phy auto-poll\r\n");
-	// wait state machine idle
-	mdelay(1000);
-	//printk("wait 1 sec end\r\n");
-	
 	return NOTIFY_DONE;
 }
 
@@ -2733,10 +4457,10 @@
 	priv->tx_ring = ring_info->tx_ring;
 	//priv->is_qf=0; // because of memset, so need not the line
 
-	//printk("ndev netdev: %s\n", ndev->name);
-	//printk("ndev addr: %p\n", ndev);
+	printk("ndev netdev: %s\n", ndev->name);
+	printk("ndev addr: %p\n", ndev);
 	netif_napi_add(ndev, &priv->napi , cns3xxx_poll, CNS3XXX_NAPI_WEIGHT);
-	dev_hold(ndev);
+        dev_hold(ndev);
 	set_bit(__LINK_STATE_START, &ndev->state);
 
 	return ndev;
@@ -2774,16 +4498,16 @@
 	set_interrupt_pri(FSRC_RING0_INTERRUPT_ID, 0xc);
 	get_interrupt_pri(FSRC_RING0_INTERRUPT_ID, &v);
 
-	get_interrupt_pri(FSRC_RING1_INTERRUPT_ID, &v);
-	set_interrupt_pri(FSRC_RING1_INTERRUPT_ID, 0xc);
-	get_interrupt_pri(FSRC_RING1_INTERRUPT_ID, &v);
-
-	get_interrupt_pri(FSQF_RING1_INTERRUPT_ID, &v);
-	set_interrupt_pri(FSQF_RING1_INTERRUPT_ID, 0xc);
-	get_interrupt_pri(FSQF_RING1_INTERRUPT_ID, &v);
+		get_interrupt_pri(FSRC_RING1_INTERRUPT_ID, &v);
+		set_interrupt_pri(FSRC_RING1_INTERRUPT_ID, 0xc);
+		get_interrupt_pri(FSRC_RING1_INTERRUPT_ID, &v);
+
+		get_interrupt_pri(FSQF_RING1_INTERRUPT_ID, &v);
+		set_interrupt_pri(FSQF_RING1_INTERRUPT_ID, 0xc);
+		get_interrupt_pri(FSQF_RING1_INTERRUPT_ID, &v);
 
 	#ifndef CONFIG_CNS3XXX_NAPI
-	set_interrupt_pri(FSQF_RING0_INTERRUPT_ID, 0xc);
+		set_interrupt_pri(FSQF_RING0_INTERRUPT_ID, 0xc);
 	#endif
 #endif // CNS3XXX_USE_MASK
 
@@ -2822,35 +4546,6 @@
 	}
 }
 
-// Waiting for DMA Status to IDLE.
-static void pse_dma_idle(void)
-{
-	//printk("Suspending DMA\n");
-	DMA_AUTO_POLL_CFG_REG |= (1<<4);
-	DMA_AUTO_POLL_CFG_REG |= (1<<0);
-	// receive all fs ring packets
-	empty_rx();
-	
-	//printk("Waiting for DMA Status not IDLE\n");
-	//printk("\n %x %x\n",TS_DMA_STA_REG,FS_DMA_STA_REG);
-	while(TS_DMA_STA_REG );
-	while(1) {
-	    if(FS_DMA_STA_REG==0) {
-	            break;
-	    }
-	    else if(FS_DMA_STA_REG==2 && FS_DMA_CTRL0_REG==0) {
-	        if(FS_DMA_STA_REG==2 && FS_DMA_CTRL0_REG==0) //check twice
-	            break;
-	    }
-	};
-	
-	//clear fs dma
-	DMA_RING_CTRL_REG |= (1 << 31);
-	while(((DMA_RING_CTRL_REG >> 30) & 1) == 0);
-	DMA_RING_CTRL_REG &= (~(1 << 31));
-	//printk("DMA Status is IDLE\n");
-}
-
 static int is_tx_empty(TXRing *tx_ring)
 {
 	u32 cur_index, ring_size = get_tx_ring_size(tx_ring);
@@ -3006,18 +4701,19 @@
 	
 	RingInfo ring_info; 
 	int i=0;
-	u32 reg_config = 0;
+	//spin_lock_init(&star_gsw_send_lock);
+
 
 #ifdef CNS3XXX_DOUBLE_RX_RING
-	ring_info.num_rx_queues = 2;
+        ring_info.num_rx_queues = 2;
 #else
-	ring_info.num_rx_queues = 1;
+        ring_info.num_rx_queues = 1;
 #endif
 
 #ifdef CNS3XXX_DOUBLE_TX_RING
-	ring_info.num_tx_queues = 2;
+        ring_info.num_tx_queues = 2;
 #else
-	ring_info.num_tx_queues = 1;
+        ring_info.num_tx_queues = 1;
 #endif
 
 	ring_info.rx_ring = kcalloc(ring_info.num_rx_queues, sizeof(RXRing), GFP_KERNEL);
@@ -3041,32 +4737,40 @@
 
 	g_ring_info = ring_info;
 
-	cns3xxx_gsw_up_init();
+cns3xxx_gsw_up_init();
+
+{
+  u32 reg_config = 0;
 
-	/* jumbo frame configuration */
-	reg_config = PHY_AUTO_ADDR_REG;
-	reg_config &= ~(3 << 30);
-
-	if (jumbo_frame) {
-		reg_config |= (3 << 30); // maximum frame length: 9600 bytes
-		MAX_PACKET_LEN = 9600;
+  reg_config = PHY_AUTO_ADDR_REG;
+  reg_config &= ~(3 << 30);
+	if(jumbo_frame) {
+	  reg_config |= (3 << 30); // maximum frame length: 9600 bytes
 	} else {
-		reg_config |= (2 << 30); // maximum frame length: 1536 bytes
-		MAX_PACKET_LEN = 1536;
+  	reg_config |= (2 << 30); // maximum frame length: 1536 bytes
 	}
 
-	PHY_AUTO_ADDR_REG = reg_config;
+  PHY_AUTO_ADDR_REG = reg_config;
   
-	printk("jumbo_frame %s\n", jumbo_frame?"on":"off");
-	printk("MAX_PACKET_LEN:%d\n", MAX_PACKET_LEN);
+	if(jumbo_frame) {
+		//MAX_PACKET_LEN = 9600;
+		printk("jumbo_frame on\n");
+		printk("MAX_PACKET_LEN:%d\n", MAX_PACKET_LEN);
+	}
+	else {
+		//MAX_PACKET_LEN = 1536;
+		printk("jumbo_frame off\n");
+		printk("MAX_PACKET_LEN:%d\n", MAX_PACKET_LEN);
+	}
+}
 
 	cns3xxx_probe(ring_info);
 	cns3xxx_config_intr();
 
 #ifdef CNS3XXX_VLAN_8021Q
-	if (is_cns3xxx_nic_mode_8021q()) {
-		cns3xxx_nic_mode(1);
-	}
+#ifdef CNS3XXX_NIC_MODE_8021Q
+	cns3xxx_nic_mode(1);
+#endif
 #endif
 	spin_lock_init(&tx_lock);
 	spin_lock_init(&rx_lock);
@@ -3102,6 +4806,7 @@
 		printk("%s: Failed to setup cpufreq notifier\n", __FUNCTION__);
 	}
 #endif
+   cns3xxx_setup_rx_tx_res(); //KH: init tx/rx ring
 
 	return 0;
 }
@@ -3110,19 +4815,18 @@
 {
 	int i=0;
 
-	//printk("g_ring_info.rx_ring: %p\n", g_ring_info.rx_ring);
-	//printk("g_ring_info.tx_ring: %p\n", g_ring_info.tx_ring);
-	kfree(g_ring_info.rx_ring);
-	kfree(g_ring_info.tx_ring);
-
-	cns3xxx_proc_remove();
-
 	for (i=0 ; i < NETDEV_SIZE ; ++i) {
 		CNS3XXXPrivate *priv = 0;
 
 		if (net_dev_array[i]){
 			priv = netdev_priv(net_dev_array[i]);
 
+			kfree(priv->tx_ring);
+			priv->tx_ring = 0;
+
+			kfree(priv->rx_ring);
+			priv->rx_ring = 0;
+
 			unregister_netdev(net_dev_array[i]);
 			free_netdev(net_dev_array[i]);
 		}
@@ -3135,10 +4839,7 @@
 	#endif
 #endif
 
-#ifdef CONFIG_CPU_FREQ
-	cpufreq_unregister_notifier(&pse_cpufreq_notifier_block, CPUFREQ_TRANSITION_NOTIFIER);
-#endif
-
+	cns3xxx_proc_remove();
 	unregister_reboot_notifier(&cns3xxx_notifier_reboot);
 	printk("remove cns3xxx pse module\n");
 
@@ -3176,8 +4877,6 @@
 }
 #endif
 
-u32 cns3xxx_main;
-EXPORT_SYMBOL(cns3xxx_main);
 
 MODULE_AUTHOR("Cavium Networks, <tech@XXXX.com>");
 MODULE_DESCRIPTION("CNS3XXX Switch Driver");
